# Глава 1. Открытые Двери Замка и Волшебные Ключи
В одном уютном лесу, в самом его сердце, стоял большой и уютный Замок Данных. Его хранителем был мудрый Медведь Django. В замке были бесценные сокровища: альбомы с воспоминаниями (фотографиями), списки самых сладких мест (базы данных) и личные дневники жителей леса (пользовательские данные).

Однажды Винни-Пух, большой любитель мёда и приключений, решил навестить Медведя. Но, подойдя к замку, он удивился: огромные дубовые ворота были распахнуты настежь!

— Хей-хо! — крикнул Пух. — Здесь кто-нибудь есть?

Из замка вышел взволнованный Пятачок.

— Ой-ой-ой! — запищал он. — Это ужасная проблема! Пока Медведь Django дремал после обеда, любой прохожий мог зайти в замок! Сова уже успела переписать все рецепты мёда, Кролик рассортировал овощи по-своему, а Иа-Иа чуть не стёр весь список грустных песен! Наш замок стал похож на дом с открытыми дверьми в самом беспокойном районе Леса.

Медведь Django проснулся, почесал в затылке и громко провозгласил:
— Пора наводить порядок! Нам нужна система проверки друзей (аутентификация). Мы должны точно знать: кто стучится в наши двери?

"Аутентификация", объяснил Медведь, — это когда мы спрашиваем гостя: "Кто ты?" и проверяем, действительно ли он тот, за кого себя выдаёт. Например, если кто-то говорит: "Я — Винни-Пух!", мы должны убедиться, что это не переодетый Тигра.

Но этого мало! — добавил мудрый Филин (он же DRF — Дремучий Разумный Филин). — Нужна еще и система пропусков (авторизация), которая отвечает на вопрос: "А что тебе здесь можно делать?" Даже если это настоящий Винни-Пух, это не значит, что ему можно залезать в кладовку Медведя или править расписание полётов Совы.

Итак, запомним:

Аутентификация = "Кто ты?" (Проверка личности).

Авторизация = "Что тебе можно?" (Проверка прав).

— Но как мы будем проверять друзей? — спросил Пятачок.

Филин DRF перечислил несколько старых, но известных в Лесу способов:

1. Простейший пропуск (Basic Authentication)
Гость кричит у ворот: "Я — Кролик:люблюМорковку!" сразу всем на слух. Это очень просто и понятно, поэтому такой способ до сих пор существует. Он идеален для быстрых тестов в своей песочнице, когда ты настраиваешь замок один и хочешь быстро проверить, работает ли стража. Но для настоящей защиты Леса он не годится — любой подслушивающий (например, Пчелы) может перехватить секретную фразу.

2. Глиняная табличка (Session Authentication)
Медведь даёт гостю, который пришёл лично, особую глиняную табличку (session cookie) и хранит у себя в кладовке её точный слепок (сессию на сервере). Гость показывает табличку при каждом новом визите, и стража сверяет её со слепком.

— А если друг шлёт своего почтового голубя с просьбой? — спросил Кролик. — Голубь же не умеет носить и предъявлять глиняные таблички!

— Верно, — кивнул Филин. — Куки (cookies) — это механизм браузера. Они отлично цепляются к лапкам голубей-браузеров, которые летают по веб-страницам. Но если друг общается с замком через мобильное приложение, умные часы или другого голубя (API-клиент), который не понимает, как обращаться с глиняными табличками, этот способ бесполезен.

3. Волшебный ключ-жетон (Token Authentication)
После первой проверки личности (логин/пароль) Медведь выдаёт гостю уникальный металлический жетон-ключ и записывает в свою книгу учёта, что этот ключ выдан такому-то другу. Теперь, чтобы попасть в любую комнату замка, гость (или его почтовый голубь) просто показывает этот жетон стражнику. Ключ действует долго, пока его не отберут или не перевыпустят.

```text
Стража проверяет заголовок письма:
"Authorization: Token 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08"
```

4. Запечатанный свиток (JWT - JSON Web Tokens)
Современное и мощное заклинание! Это не просто ключ, а самодостаточный запечатанный свиток (токен). Он состоит из трёх частей, склеенных точкой:

Заголовок (Header): Тип свитка ("JWT") и рецепт магической печати (алгоритм шифрования, например, HS256).

Полезная нагрузка (Payload): Сюда записана вся информация о госте (его ID, роль, срок действия токена). Эти данные НЕ зашифрованы, их может прочитать каждый, но изменить нельзя.

Печать (Signature): Это и есть волшебная печать. Она создаётся из Заголовка, Полезной нагрузки и секретного ключа Медведя. Подделать её невозможно, не зная секрета. Именно печать гарантирует, что свиток не подменили.

Вот как выглядит такой свиток:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsInJvbGUiOiJ1c2VyIn0.4P5NYRoQ9isGqwS8Gb0YvBRtk9dcbG6AzlvEl5jOYz4
(Три части, разделённые точками: Header.Payload.Signature)
```

— А этот свиток передаётся в куках? — уточнил Пятачок.

— Нет! — ответил Филин. — Весь свиток — это одна длинная закодированная строка. Она передаётся в специальном заголовке HTTP-запроса, точно так же, как жетон. Это делает свиток универсальным для любого посланника.

— Фух, — сказал Винни-Пух, у которого от этих подробностей слегка закружилась голова. — Значит, чтобы защитить наш мёд... то есть наши данные, нужно правильно выбирать, кого и как пускать в замок?

— Именно так, дружище! — похлопал его по плечу Медведь. — Без проверки друзей наш замок — просто публичная столовая для всех подряд. А мы этого не хотим.

Вот как Филин DRF устроил проверку у ворот (под капотом):

1. Приходит HTTP-запрос (request) — это как официальное письмо от гостя. В нём есть адрес (URL), метод (GET, POST) и разные служебные поля (заголовки).

2. Стража (DRF) смотрит, есть ли в письме заголовок "Authorization".

3. Если есть, стража передаёт его специальному классу-проверяльщику (класс аутентификации).

4. Проверяльщик изучает пропуск (жетон, свиток). Если всё в порядке, он добавляет в объект запроса (request) найденного пользователя. Теперь внутри обработчика (во view) мы можем обращаться к request.user — и это будет тот самый проверенный друг (например, объект пользователя Винни-Пуха). Если проверка не прошла, request.user останется анонимным.

Медведь показал в своей главной книге заклинаний (settings.py), как настроить этих проверяльщиков:

```python
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.BasicAuthentication',  # Простой пропуск
        'rest_framework.authentication.TokenAuthentication',   # Жетоны
    ]
}
```

Проверка будет идти по списку: сначала попробуют простой пропуск, потом — жетон.

И сразу создали первую защищённую комнату в замке (Protected View):

```python
# views.py в замке
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

class SecretChamberView(APIView):
    # "Классы разрешений" - это правила, КТО может сюда входить.
    # IsAuthenticated - самое простое правило: "Входить могут только те, кого стража уже проверила (аутентифицировала)".
    permission_classes = [IsAuthenticated]

    def get(self, request):
        # Теперь request.user содержит объект аутентифицированного пользователя
        return Response({"message": f"Welcome, {request.user.username}!"})
```

Пример полного диалога с замком:

Запрос от Почтового Голубя (клиента) к Замку (серверу):

```text
GET /api/secret-chamber/ HTTP/1.1           # Метод и путь к защищённой комнате
Host: honeycastle.local                     # Адрес замка
Authorization: Token abc123def456           # ЗАГОЛОВОК с пропуском-жетоном (ОБЯЗАТЕЛЬНО здесь, а не в теле!)
Content-Type: application/json              # Тип передаваемых данных
User-Agent: Postman/10.0                    # Кто отправляет запрос

{                                           # ТЕЛО запроса (если нужно). Для GET-запроса обычно пустое.
    "note": "Это тело запроса. Сюда НЕ нужно класть токен!"
}
```

Ответ Замка (сервера) Голубю (клиенту):

```text
HTTP/1.1 200 OK                             # Статус: Успешно!
Content-Type: application/json              # Тип данных в ответе
Date: Mon, 15 Apr 2024 10:00:00 GMT

{                                           # ТЕЛО ответа с данными
    "message": "Welcome, Winnie-the-Pooh!"
}
```

— Главное, — предупредил Филин, — не забывать указывать пропуск в заголовке HTTP-запроса (строки Authorization: ...), а не в его теле (которое после пустой строки). И всегда настраивать проверяльщиков в главной книге (settings.py). Иначе все эти жетоны и свитки будут просто бесполезными безделушками!

Так жители Леса поняли самую важную основу: их уютный Замок Данных нуждается в надёжных дверях и умной страже. А Винни-Пух уже с нетерпением ждал, когда же ему выдадут его собственный волшебный ключ-жетон.


# Глава 2 Тайна Волшебного Жетона
Теперь, когда жители Леса поняли важность защиты своего Замка Данных, настало время разобраться с первым по-настоящему мощным заклинанием — Волшебным Жетоном (Token).

— Так что же это за жетон такой? — спросил Винни-Пух, с любопытством разглядывая блестящий металлический кружок, который Филин DRF держал в лапе.

— Представь, — начал объяснять Филин, — что ты приходишь к Медведю в гости. Ты называешь себя, Медведь сверяет твоё лицо с портретом в своей книге друзей (проверяет логин и пароль) и говорит: «Да, это точно Пух!». Вместо того чтобы заставлять тебя каждый раз называть своё имя, он выдаёт тебе этот жетон — уникальный пропуск.

### Как работает Волшебный Жетон:

1. Первый визит (логин): Ты предъявляешь свои документы (логин/пароль). Медведь проверяет их.

2. Выдача пропуска: Если всё верно, Медведь достаёт из сейфа и вручает тебе жетон с магическим номером. Этот номер он сразу записывает в свою Книгу Учёта Жетонов (базу данных).

3. Все последующие визиты: Теперь, подходя к любой двери замка, ты просто молча показываешь жетон. Стража смотрит на его номер, находит запись в Книге, видит: «Ага, этот жетон выдан Винни-Пуху». И пропускает тебя!

— Это как электронный пропуск в большой офис! — воскликнул Кролик, который иногда бывал в городе. — Один раз получил бейджик, и ходишь с ним целый день, куда нужно.

— Совершенно верно! — подтвердил Филин. — Или как бейджик для кофемашины у вас, программистов: получил один раз, и пока он действует — пьёшь кофе без лишних вопросов.

### Почему все в Лесу полюбили жетоны?

— Подожди-подожди, — вмешался Кролик. — Ты говорил про глиняные таблички. Но в чём разница? Медведь и там что-то хранил, и здесь хранит Книгу Учёта. Какая разница?

— Отличный вопрос! — воскликнул Филин. — Разница в том, ЧТО именно хранится.

### Глиняная табличка (Сессия):

Когда ты приходишь в первый раз, Медведь лепит твой точный портрет из глины (создаёт сессию) и ставит его в кладовку.

Тебе он даёт квитанцию (session ID в cookie).

Каждый раз, когда ты возвращаешься, ты показываешь квитанцию. Стража бежит в кладовку, находит твой портрет и говорит: «Да, это Пух!».

Проблема: Если замок вырастет, и появятся другие башни со своими стражами, им всем придётся иметь копию твоего портрета! Или бегать в главную кладовку. Это неудобно.

### Волшебный жетон (Токен):

Когда ты приходишь в первый раз, Медведь проверяет твой паспорт и выдаёт уникальный жетон с номером.

В кладовке он записывает в Книгу: «Жетон №123 выдан Винни-Пуху».

Ты показываешь жетон — стража смотрит в Книгу и видит запись.

Преимущество: Вся информация — в жетоне (номер) и в Книге (кому выдан). Никаких глиняных портретов!

— А почему сессии живут долго? — спросил Пятачок.
— Потому что их часто делают «вечными» или очень долгими, — объяснил Филин. — Ушёл ты из замка, а твой глиняный портрет ещё месяц стоит в кладовке! А жетону можно задать срок — час, день, неделя. Истёк срок — выкидывай.

— Но как другие серверы-стражи будут заглядывать в нашу Книгу? — поинтересовался Винни-Пух.

— Очень просто! — сказал Филин. — Книга Учёта — это база данных. Все стражи (серверы) умеют разговаривать с одной общей базой данных. Это как если бы у всех башен была труба-телефон, соединённая с главной кладовкой.

### Как это выглядит в коде замка?

— А теперь самое интересное! — воскликнул Филин и раскрыл книгу заклинаний. — Давайте создадим свой жетон, чтобы понять его изнутри.

### 1. Создание Модели Жетона (models.py) — Чертеж для Книги Учёта

— Смотрите, — сказал Филин, указывая на код. — Это чертёж записи в Книге Учёта. Мы говорим Django: «Дорогой, когда ты будешь создавать записи в таблице MagicToken, делай их вот по такому образцу».

```python
# models.py в приложении 'api'
from django.db import models
from django.contrib.auth.models import User
from django.utils.timezone import now
import uuid  # Волшебный генератор уникальных номеров!

class MagicToken(models.Model):
    # 1. Уникальный ключ жетона
    key = models.UUIDField(
        default=uuid.uuid4,      # При создании: "Генерируй случайный UUID!"
        editable=False,          # "И никогда не меняй его после создания!"
        unique=True              # "И следи, чтобы не было двух одинаковых!"
    )
    
    # 2. Связь с пользователем
    user = models.OneToOneField(
        User, 
        on_delete=models.CASCADE # "Если удалят пользователя - удаляй и его жетон!"
    )
    
    # 3. Когда создан
    created_at = models.DateTimeField(
        auto_now_add=True        # "При создании ставь текущую дату-время!"
    )
    
    # 4. До какого числа действует
    expires_at = models.DateTimeField()  # "Эту дату мы зададим при выковке жетона"

    def is_valid(self):
        """Магическое заклинание для проверки срока годности"""
        # Сравниваем: сейчас раньше, чем expires_at?
        return now() < self.expires_at
```

— Но где же создаются объекты этого класса? — спросил Винни-Пух.

— Отличный вопрос! — ответил Филин. — Django ORM (Волшебный Переводчик) создаёт их за нас! Когда мы пишем MagicToken.objects.create(...), ORM:

Берёт наш чертёж (класс MagicToken)

Создаёт объект в памяти

Записывает его в базу данных

А метод is_valid() вызывается позже, когда нужно проверить жетон

### 2. Кузница жетонов (views.py) — где выковывают жетоны

— Теперь создадим кузницу, — продолжил Филин. — Место, куда друзья приносят свои пароли и получают жетоны.

```python
# views.py
from django.utils.timezone import now, timedelta
from rest_framework.views import APIView      # Базовый класс для API-комнат
from rest_framework.response import Response  # Инструмент для создания ответов
from rest_framework import status             # Магические коды статусов (200, 400, 404)
from django.contrib.auth import authenticate  # Заклинание проверки пароля
from .models import MagicToken

class ObtainMagicTokenView(APIView):
    """Волшебная кузница: пароль на вход → жетон на выход"""
    
    def post(self, request):
        # Клиент присылает в теле письма имя и пароль
        username = request.data.get("username")
        password = request.data.get("password")
        
        # Заклинание authenticate проверяет: есть ли такой пользователь?
        user = authenticate(username=username, password=password)
        
        if user:  # Если пользователь найден и пароль верный
            # Сначала уничтожим старые жетоны этого пользователя
            # MagicToken.objects - это доступ к Книге Учёта
            # .filter(user=user) - "Найди все записи, где user равен нашему пользователю"
            # .delete() - "Удали их!" (чтобы у пользователя был только один активный жетон)
            MagicToken.objects.filter(user=user).delete()
            
            # Выковываем новый жетон!
            # MagicToken.objects.create(...) - создаёт запись в Книге Учёта
            token = MagicToken.objects.create(
                user=user,  # Кому выдаём
                expires_at=now() + timedelta(hours=1)  # Действует 1 час
            )
            
            # Отправляем жетон клиенту
            return Response({"token": token.key}, status=status.HTTP_200_OK)
        
        # Если пароль неверный
        return Response({"error": "Invalid credentials"}, 
                       status=status.HTTP_400_BAD_REQUEST)
```

— Что такое APIView? — спросил Пятачок.

— Это волшебный чертёж для создания API-комнат! — объяснил Филин. — Когда ты наследуешь от APIView, твой класс становится «умной комнатой», которая:

Сама понимает HTTP-методы (GET, POST, PUT, DELETE)

Умеет обрабатывать запросы

Автоматически создаёт красивые JSON-ответы

DRF сам создаёт объект этого класса при первом обращении к URL и вызывает нужный метод!

### 3. Как выглядит обмен пароля на жетон:

Запрос клиента:

```text
POST /api/get-token/ HTTP/1.1
Content-Type: application/json

{"username": "winnie", "password": "honey123"}
```

Ответ сервера (кузницы):

```text
HTTP/1.1 200 OK
Content-Type: application/json

{"token": "550e8400-e29b-41d4-a716-446655440000"}
```

### 4. Использование жетона

— А как потом использовать этот жетон? — спросил Винни-Пух.
— Очень просто! — сказал Филин и нарисовал:

```bash
# Голубь летит к защищённой комнате с жетоном
curl -X GET http://honeycastle.local/api/secret-honey-storage/ \
  -H "Authorization: Token 550e8400-e29b-41d4-a716-446655440000"
```

### 5. Проверяльщик жетонов (authentication.py)

— Но кто будет проверять эти жетоны? — спросил Кролик.
— Специальный класс-проверяльщик! — ответил Филин.

```python
# authentication.py
from rest_framework.authentication import BaseAuthentication  # Базовый чертёж для проверяльщиков
from rest_framework.exceptions import AuthenticationFailed    # Заклинание "Доступ запрещён!"
from .models import MagicToken

class MagicTokenAuthentication(BaseAuthentication):
    """Этот проверяльщик специализируется на волшебных жетонах"""
    
    def authenticate(self, request):
        # DRF вызывает этот метод для КАЖДОГО запроса автоматически!
        # request - это всё письмо от клиента (заголовки, тело, метод и т.д.)
        
        # 1. Ищем заголовок Authorization
        auth_header = request.headers.get("Authorization")
        
        # 2. Проверяем, начинается ли он с "Token "
        if not auth_header or not auth_header.startswith("Token "):
            return None  # "Это не наш случай, пусть другие проверяльщики смотрят"
        
        # 3. Извлекаем ключ: "Token ABC" → ["Token", "ABC"] → берём "ABC"
        try:
            key = auth_header.split(" ")[1]
        except IndexError:
            return None  # Неправильный формат
        
        # 4. Ищем жетон в Книге Учёта
        try:
            token = MagicToken.objects.get(key=key)
        except MagicToken.DoesNotExist:
            # Жетон не найден! Кидаем заклинание "Доступ запрещён!"
            raise AuthenticationFailed("Invalid token")
        
        # 5. Проверяем срок действия
        # Вот где вызывается наш метод is_valid()!
        if not token.is_valid():
            raise AuthenticationFailed("Token has expired")
        
        # 6. Всё ок! Возвращаем (пользователя, токен)
        # DRF положит пользователя в request.user, а токен в request.auth
        return (token.user, token)
```

— А кто вызывает is_valid()? — уточнил Винни-Пух.

— Мы сами вызываем его вот здесь, в проверяльщике! — показал Филин. — if not token.is_valid(): — это и есть вызов нашего метода.

### 6. Настройка проверяльщика (settings.py)

— И последний шаг, — сказал Филин, — нужно прописать нашего проверяльщика в уставе замка, чтобы стража начала его использовать.

```python
# settings.py
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'api.authentication.MagicTokenAuthentication',  # "Используй этого проверяльщика!"
    ],
}
```

### Как работает вся система:

1. Клиент → POST с логином/паролем → получает жетон

2. Клиент → GET с заголовком Authorization: Token ...

3. DRF → создаёт объект MagicTokenAuthentication → вызывает authenticate()

4. Проверяльщик → ищет жетон в базе → проверяет срок → возвращает пользователя

5. DRF → кладёт пользователя в request.user

6. Представление → видит request.user → понимает, кто это → выдаёт данные

— Ух ты! — воскликнул Винни-Пух. — Это же как настоящая магия! Только вместо волшебных палочек — код, а вместо заклинаний — методы!

— Именно! — улыбнулся Филин. — Токен — это ключ к доверию. Получил его один раз — и пользуйся, пока он действует. А в следующей главе мы узнаем о ещё более могущественном заклинании — Запечатанном Свитке (JWT), который вообще не требует Книги Учёта!

Жители Леса смотрели на блестящий жетон с новым уважением. Казалось бы, простая безделушка, а сколько силы и порядка она может принести в их уютный, но такой уязвимый мир.


# Глава 3 Стандартная Кузница Жетонов от DRF
На следующее утро Винни-Пух, Пятачок и Кролик собрались в главном зале замка. Филин DRF разложил перед ними новые свитки с заклинаниями.

— Вчера мы создали свой волшебный жетон с нуля, — начал Филин. — Это было отлично для понимания, но представьте: каждый раз, когда вам нужно забить гвоздь, вы сначала идёте в кузницу, плавите железо, куёте молоток... А потом уже забиваете гвоздь!

— Ой-ой-ой! — запищал Пятачок. — Это же очень долго!

— Именно! — кивнул Филин. — Поэтому мудрые строители Django REST Framework уже создали для нас готовую, отлаженную кузницу жетонов. Она называется TokenAuthentication. Давайте научимся ей пользоваться!

Установка волшебного инструментария

— Для начала нам нужно убедиться, что у нас есть все необходимые инструменты, — сказал Филин, доставая волшебный свиток-инструкцию.

```bash
# В волшебной консоли (терминале) выполняем:
pip install djangorestframework
```

— Но это же у нас уже есть! — воскликнул Кролик.

— Верно! — подтвердил Филин. — Но внутри DRF есть специальный модуль для работы с токенами — rest_framework.authtoken. Его нужно активировать в настройках замка.

### Шаг 1: Активация модуля токенов (settings.py)

Филин открыл главную книгу законов замка — файл settings.py:

```python
# settings.py — Главная книга законов замка
INSTALLED_APPS = [
    # ... другие приложения ...
    'rest_framework',           # Фреймворк для создания API
    'rest_framework.authtoken', # Модуль для работы с токенами (ВОТ ЭТО НОВОЕ!)
]
```

— После этого, — продолжил Филин, — нужно обновить магические таблицы базы данных:

```bash
python manage.py migrate
```

— Что делает эта команда? — спросил Винни-Пух.

— Она говорит Django: «Дорогой, у нас появилось новое приложение authtoken. Пожалуйста, создай для него таблицы в нашей базе данных!» — объяснил Филин. — Django создаст таблицу authtoken_token — это и будет наша стандартная Книга Учёта Жетонов.

### Шаг 2: Настройка проверяльщика жетонов

— Теперь нужно сказать страже, чтобы она использовала стандартного проверяльщика, — сказал Филин, добавляя новые строки в settings.py:

```python
# settings.py
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',  # Стандартный проверяльщик!
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',  # По умолчанию пускаем только проверенных
    ],
}
```

— Видите разницу? — спросил Филин. — Вчера мы писали 'api.authentication.MagicTokenAuthentication' (наш самодельный), а сегодня — 'rest_framework.authentication.TokenAuthentication' (готовый от DRF).

### Шаг 3: Создание жетонов для друзей

— А как теперь создавать жетоны? — спросил Пятачок.

— Есть несколько способов! — ответил Филин. — Первый — через волшебную консоль:

```bash
# Создаём жетон для пользователя 'winnie'
python manage.py drf_create_token winnie
```

— И что произойдёт? — с интересом спросил Винни-Пух.

— Консоль выдаст что-то вроде:

```text
Generated token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b for user winnie
```

— Это и есть твой волшебный жетон! — закончил Филин.

### Шаг 4: Создание защищённой комнаты (как вчера, но проще!)

— Давайте создадим защищённую комнату, — предложил Кролик.

— Отличная идея! — согласился Филин. — Но теперь это будет ещё проще, потому что проверяльщик у нас уже готовый.

```python
# views.py — чертежи комнат замка
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

class SecretHoneyStorageView(APIView):
    """
    Секретное хранилище мёда.
    Доступно только друзьям с волшебными жетонами!
    """
    permission_classes = [IsAuthenticated]  # Только для аутентифицированных!

    def get(self, request):
        # request.user уже содержит объект пользователя!
        # DRF сам его подставил после проверки жетона
        return Response({
            'message': f'Добро пожаловать, {request.user.username}!',
            'secret': 'Здесь хранится самый вкусный мёд в лесу!'
        })
```

— И добавляем дверь к этой комнате, — сказал Филин, открывая файл urls.py:

```python
# urls.py — карта дверей замка
from django.urls import path
from .views import SecretHoneyStorageView

urlpatterns = [
    path('api/secret-honey/', SecretHoneyStorageView.as_view(), 
         name='secret_honey_storage'),
]
```

### Шаг 5: Тестирование жетона

— Давайте проверим! — воскликнул Винни-Пух. — У меня же есть жетон: 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b.

Филин взял свиток и написал тестовое письмо:

```bash
# Письмо от Винни-Пуха с жетоном
curl -X GET http://замок-данных.лес/api/secret-honey/ \
  -H "Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b"
```

— И что ответит замок? — заинтересовался Кролик.

— Если жетон правильный:

```json
{
    "message": "Добро пожаловать, winnie!",
    "secret": "Здесь хранится самый вкусный мёд в лесу!"
}
```

— А если без жетона или с неправильным? — спросил Пятачок.

Филин взял другой свиток и написал:

```bash
# Письмо без жетона
curl -X GET http://замок-данных.лес/api/secret-honey/
```

— Тогда сервер ответит:

```json
{
    "detail": "Учетные данные не были предоставлены."
}
```

— Откуда берётся такой ответ? — удивился Винни-Пух.

— Это стандартный ответ DRF, когда разрешение IsAuthenticated не видит аутентифицированного пользователя! — объяснил Филин. — Внутри DRF есть специальный обработчик, который ловит все случаи, когда доступ запрещён, и формирует красивый JSON-ответ с объяснением. И статус при этом будет 401 Unauthorized.

Программное создание жетонов

— А если я хочу создавать жетоны автоматически? — спросил Кролик, который любил автоматизацию. — Например, когда новый друг регистрируется в замке?

— Отличный вопрос! — похвалил Филин. — Вот как это делается:

```python
# Где-нибудь в коде регистрации
from rest_framework.authtoken.models import Token  # Импортируем стандартную модель Token из DRF!
from django.contrib.auth.models import User
```

— Что такое этот модуль Token? — спросил Пятачок.
— Это готовая модель из пакета rest_framework.authtoken, — объяснил Филин.
Когда мы добавили 'rest_framework.authtoken' в INSTALLED_APPS,
Django создал таблицу в базе данных и модель для работы с ней.
Эта модель очень похожа на нашу MagicToken, но уже готовая и протестированная!

Допустим, у нас есть пользователь
```
user = User.objects.get(username='piglet')
```

— Создаём или получаем существующий токен
get_or_create — волшебное заклинание, которое:
1. Ищет токен для этого пользователя
2. Если находит — возвращает его
3. Если не находит — создаёт новый и возвращает
```
token, created = Token.objects.get_or_create(user=user)
```

token.key — это сам жетон!
```
print(f"Жетон Пятачка: {token.key}")
```

— Давайте покажем, как это выглядит на практике при регистрации! — предложил Винни-Пух.

### Пример: Регистрация нового друга с автоматическим созданием жетона

```python
# Пример обработчика регистрации
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth.models import User
from rest_framework.authtoken.models import Token

class RegisterView(APIView):
    def post(self, request):
        username = request.data.get('username')
        password = request.data.get('password')
        email = request.data.get('email')
        
        if User.objects.filter(username=username).exists():
            return Response(
                {'error': 'Пользователь с таким именем уже существует'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Создаём пользователя
        user = User.objects.create_user(
            username=username,
            password=password,
            email=email
        )
        
        # Автоматически создаём токен для нового пользователя
        token = Token.objects.create(user=user)
        
        return Response({
            'message': 'Регистрация успешна!',
            'username': user.username,
            'token': token.key  # Отправляем жетон сразу при регистрации!
        }, status=status.HTTP_201_CREATED)
```

Запрос на регистрацию:

```bash
curl -X POST http://замок-данных.лес/api/register/ \
  -H "Content-Type: application/json" \
  -d '{"username": "tigger", "password": "bounce123", "email": "tigger@forest.com"}'
```

Ответ сервера:

```json
{
    "message": "Регистрация успешна!",
    "username": "tigger",
    "token": "c7f8d9e0a1b2c3d4e5f6a7b8c9d0e1f2"
}
```

— Видите? — сказал Филин. — Тигра только зарегистрировался, а уже получил свой волшебный жетон и может сразу им пользоваться!

### Типичные проблемы и их решения

— А что если что-то пойдёт не так? — спросил осторожный Пятачок.

Филин достал ещё один свиток — «Справочник по устранению неполадок»:

1. Проблема: В представлении request.user — анонимный пользователь (AnonymousUser).
Решение: Проверь, что TokenAuthentication указан в DEFAULT_AUTHENTICATION_CLASSES в settings.py.

2. Проблема: Жетон есть, но доступ запрещён (401 Unauthorized).
Решение: Проверь формат заголовка. Должно быть: Authorization: Token ваш_жетон_здесь (с пробелом после Token). И проверь, не истёк ли срок действия (если ты использовал свою модель с expires_at).

3. Проблема: После миграции появились дублирующиеся жетоны.
Решение: Проверь, нет ли конфликта миграций. Можно очистить таблицу токенов и создать заново.

4. Проблема: При регистрации токен не создаётся.
Решение: Убедись, что вызвал Token.objects.create(user=user) после создания пользователя.

— И помните главное, — заключил Филин, — стандартный TokenAuthentication от DRF — это как готовый инструмент из магазина. Не нужно ковать свой молоток, когда можно взять готовый, отлично сбалансированный!

— Ура! — закричал Винни-Пух. — Теперь у меня есть волшебный жетон, и я могу получать доступ к секретному мёду!

— Но это только начало, — таинственно сказал Филин. — Завтра мы познакомимся с самым современным и мощным заклинанием — JSON Web Tokens (JWT). Эти свитки настолько умные, что им даже не нужна Книга Учёта!

Жители Леса разошлись по домам, у каждого в голове крутились мысли о жетонах, проверках и безопасных API. А Винни-Пух крепко сжимал в лапе свой первый волшебный жетон — ключ к секретам замка данных.


# Глава 4 Автоматическая Кузница и Умные Пропуска
Через несколько дней жители Леса снова собрались в замке. Винни-Пух уже успел попробовать свой волшебный жетон и был в восторге.

— Это же просто волшебство! — воскликнул он. — Один раз получил жетон, и теперь могу брать мёд из секретного хранилища, когда захочу!

— Да, жетоны — это удобно, — согласился Филин. — Но представьте: каждый раз, когда в замок приходит новый друг, кто-то должен бежать в консоль и выполнять drf_create_token. Это как если бы на каждую новую почтовую марку нужно было идти к королю за личной печатью!

— Ой-ой-ой! — запищал Пятачок. — Это же неудобно!

— Именно! — кивнул Филин. — Поэтому сегодня мы сделаем нашу кузницу жетонов полностью автоматической! И узнаем, как правильно использовать жетоны в разных ситуациях.

Волшебная автоматическая кузница

— Помните, вчера мы вручную создавали жетоны? — спросил Филин. — Сегодня мы настроим сигналы Django — это как волшебные слухи, которые разносятся по замку, когда что-то происходит.

— Слухи? — удивился Винни-Пух.
— Да! — подтвердил Филин. — Например, когда рождается новый житель Леса (создаётся пользователь), по замку разносится слух: «Эй, все! Только что родился новый друг!» И наша автоматическая кузница, услышав этот слух, сразу же выковывает для него жетон!

### Шаг 1: Настройка сигналов (signals.py)

Филин открыл новый свиток и начал писать заклинание:

```python
# signals.py в приложении 'api'
from django.conf import settings
from django.db.models.signals import post_save  # Импортируем "слух": "после сохранения"
from django.dispatch import receiver  # Импортируем "ухо", которое будет слушать
from rest_framework.authtoken.models import Token  # Наша стандартная модель токенов

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    """
    Волшебное заклинание, которое срабатывает КАЖДЫЙ РАЗ,
    когда сохраняется объект пользователя.
    """
    if created:  # Если пользователь только что создан (а не просто обновлён)
        Token.objects.create(user=instance)  # Создаём для него токен!
        print(f"Автоматически создан токен для пользователя {instance.username}")
```

— Подожди! — остановил Филина Кролик. — Кто, когда и как передаёт параметры в эту функцию? sender, instance, created — откуда они берутся?

— Отличный вопрос! — похвалил Филин. — Django сам передаёт эти параметры, когда срабатывает сигнал post_save. Вот как это работает:

Когда вы вызываете user.save() или User.objects.create(...), Django после сохранения в базу сам вызывает все функции, которые слушают сигнал post_save для модели User.

- sender — это сама модель, которая отправила сигнал (в нашем случае User).

- instance — это конкретный объект пользователя, который только что сохранили.

- created — это булево значение: True, если объект был создан, False, если он был обновлён.

Мы используем if created:, чтобы создавать токен только для новых пользователей, а не при каждом обновлении их профиля!

— А как этот токен потом попадает в HTTP-ответ? — спросил Винни-Пух.

— А вот так! — сказал Филин и открыл другой свиток. — Когда пользователь логинится через /api/token/, встроенный обработчик obtain_auth_token ищет токен этого пользователя в базе (который мы только что создали через сигнал) и возвращает его в ответе:

```python
# Внутри obtain_auth_token происходит примерно это:
token = Token.objects.get(user=user)  # Находим токен, созданный сигналом
return Response({'token': token.key})  # Отправляем его в HTTP-ответе
```

### Шаг 2: Активация слуха (apps.py)

— Но чтобы «ухо» начало слушать, его нужно включить! — продолжил Филин. — Для этого откроем файл apps.py нашего приложения:

```python
# apps.py приложения 'api'
from django.apps import AppConfig

class ApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'api'
    
    def ready(self):
        """
        Этот метод вызывается, когда приложение готово к работе.
        Здесь мы "включаем" наши сигналы.
        """
        import api.signals  # Импортируем файл с сигналами
        # Теперь наше "ухо" активно и будет слушать сигналы!
```

### Шаг 3: Встроенная кузница от DRF

— А знаете, что самое удобное? — сказал Филин с улыбкой. — DRF уже предоставляет готовый эндпоинт для получения токенов! Его даже не нужно писать!

Он открыл файл urls.py:

```python
# urls.py замка
from django.urls import path
from rest_framework.authtoken.views import obtain_auth_token  # Готовый обработчик!

urlpatterns = [
    # ... другие пути ...
    path('api/token/', obtain_auth_token, name='api_token_auth'),
    # ВОТ И ВСЁ! Больше ничего писать не нужно!
]
```

— Что делает obtain_auth_token? — спросил Винни-Пух.

— Это встроенный обработчик от DRF, который:

- Принимает POST-запрос с username и password

- Проверяет их

- Если всё верно — возвращает токен

- Если нет — возвращает ошибку

### Пример работы автоматической кузницы:

Запрос на получение токена:

```bash
curl -X POST http://замок-данных.лес/api/token/ \
  -H "Content-Type: application/json" \
  -d '{"username": "winnie", "password": "honey123"}'
```

Ответ сервера:

```json
{
    "token": "9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b"
}
```
— И не нужно писать свой ObtainMagicTokenView, как мы делали раньше! — восхитился Кролик.

— Совершенно верно! — подтвердил Филин. — DRF уже всё сделал за нас!

### Шаг 4: Использование токена в запросах

— Теперь давайте создадим разные защищённые комнаты и посмотрим, как токены работают в реальных ситуациях, — предложил Филин.

```python
# views.py — новые защищённые комнаты
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

@api_view(['GET'])  # Говорим: эта функция обрабатывает ТОЛЬКО GET-запросы
@permission_classes([IsAuthenticated])  # Только для аутентифицированных!
def protected_honey_view(request):
    """
    Защищённое хранилище мёда.
    Доступно только с правильным токеном!
    """
    return Response({
        "message": f"Привет, {request.user.username}!",
        "secret": "Здесь хранится секретный запас мёда на зиму!",
        "your_token": str(request.auth)  # request.auth содержит объект токена!
    })
```

— Обратите внимание на декораторы! — указал Филин. — @api_view(['GET']) превращает обычную функцию в обработчик API, а @permission_classes([IsAuthenticated]) задаёт правила доступа.

Добавляем дверь к этой комнате:

```python
# urls.py
from django.urls import path
from .views import protected_honey_view

urlpatterns = [
    # ... другие пути ...
    path('api/honey-vault/', protected_honey_view, name='honey_vault'),
]
```

### Шаг 5: Практические примеры использования токенов

Филин разложил перед друзьями несколько свитков с примерами:

### Пример 1: Мобильное приложение «Мёд на вынос»
— Представьте, что у вас есть мобильное приложение, — начал Филин. — Пользователь входит один раз, получает токен и сохраняет его в памяти телефона. Теперь при каждом открытии приложения оно отправляет токен и получает свежий мёд!

```python
# Пример запроса из мобильного приложения
import requests

token = "9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b"
headers = {"Authorization": f"Token {token}"}
response = requests.get("http://замок-данных.лес/api/honey-vault/", headers=headers)
```

— А что делает response.json()? — спросил Пятачок.

— Это метод библиотеки requests, который ПАРСИТ (разбирает) JSON-ответ от сервера
и превращает его в Python-словарь или список!
```
honey_data = response.json()  # Получаем данные мёда в виде словаря Python!
print(honey_data['secret'])  # Выведет: "Здесь хранится секретный запас мёда на зиму!"
```

### Пример 2: Интеграция с Умным Ульем
— А что если Умный Улей хочет автоматически сообщать о количестве собранного мёда? — продолжил Филин.

— Вы говорили, что можно выдать улью токен с ограниченными правами, — вспомнил Кролик. — Что это значит?

— Это значит, — объяснил Филин, — что мы создаём специальное представление, которое:

- Проверяет токен

- Смотрит, кому он принадлежит

- Ограничивает действия в зависимости от пользователя

```python
# Пример защищённого представления для улья
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def hive_data_view(request):
    """
    Принимает данные от улья.
    Но проверяет: а улей ли это на самом деле?
    """
    # Проверяем имя пользователя
    if request.user.username != 'smart_hive_001':
        return Response({'error': 'Доступ только для умных ульев!'}, status=403)
    
    # Если это наш улей — принимаем данные
    honey_collected = request.data.get('honey_collected')
    # Сохраняем данные...
    return Response({'status': 'Данные приняты!'})
```
— То есть ограничения задаём мы сами в коде представления! — понял Винни-Пух. — Мы решаем, какие действия разрешить каждому пользователю.

— Именно! — подтвердил Филин. — Или используем готовые разрешения DRF, но об этом в другой главе.

### Пример 3: Веб-приложение (SPA)
— А для одностраничных веб-приложений, — сказал Филин, — токен хранится в localStorage браузера.

— Что такое localStorage? — спросил Пятачок.

— Это встроенное хранилище в браузере, как кармашек в куртке! — объяснил Филин. — JavaScript может положить туда данные (например, токен), и они сохранятся даже после закрытия браузера!

```javascript
// JavaScript в браузере
// Получаем токен из localStorage (если он там есть)
const token = localStorage.getItem('honey_token');

// Отправляем запрос с токеном
fetch('/api/honey-vault/', {
    headers: {
        'Authorization': `Token ${token}`
    }
})
.then(response => response.json())  // response.json() в JavaScript тоже парсит JSON!
.then(data => {
    console.log(data);  // Выводим данные в консоль
    // Можно показать их на странице
    document.getElementById('honey-secret').textContent = data.secret;
});
```
— А как токен попадает в localStorage? — спросил Кролик.

— После успешного входа через форму! — ответил Филин. — Приложение получает токен от сервера и сохраняет его:

```javascript
// После успешного входа
localStorage.setItem('honey_token', '9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b');
```

### Шаг 6: Отладка и решение проблем

— А что делать, если токен не работает? — спросил осторожный Пятачок.

— Давайте создадим «лабораторию отладки»! — предложил Филин.

Проверка токена в админке:

— Залогинься в админку Django (/admin/)
— Найди раздел «Токены» (Tokens)
— Убедись, что у пользователя есть токен

— А если нет токена? — спросил Винни-Пух. — Как создать его вручную, самому придумать?

— Есть несколько способов! — ответил Филин.

### Способ 1: Через админку Django

- Зайди в админку (/admin/)

- Найди «Токены» → «Добавить токен»

- Выбери пользователя → «Сохранить»

- Django сам сгенерирует уникальный токен!

### Способ 2: Через консоль Django (shell)

```bash
python manage.py shell
python
from django.contrib.auth.models import User
from rest_framework.authtoken.models import Token

user = User.objects.get(username='winnie')
token = Token.objects.create(user=user)
print(f"Токен Винни-Пуха: {token.key}")
```

### Способ 3: Через команду manage.py

```bash
python manage.py drf_create_token winnie
```

Проверка заголовка запроса:

```bash
# Неправильно (токен в теле запроса):
curl -X GET http://замок-данных.лес/api/honey-vault/ \
  -d '{"token": "9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b"}'

# Правильно (токен в заголовке):
curl -X GET http://замок-данных.лес/api/honey-vault/ \
  -H "Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b"
```

Проверка настроек в settings.py:

— Убедись, что TokenAuthentication есть в DEFAULT_AUTHENTICATION_CLASSES

— Убедись, что rest_framework.authtoken есть в INSTALLED_APPS

### Шаг 7: Создание разных уровней доступа

— А можно сделать так, чтобы разные друзья имели разные права? — спросил Кролик.

— Конечно! — ответил Филин. — Но это тема для отдельной главы про разрешения (permissions). А пока запомните: токен — это ключ от двери. А какие комнаты открывает этот ключ — решают разрешения!

### Итог дня

— Давайте подведём итоги, — сказал Филин, собирая свитки. — Сегодня мы научились:

- Автоматически создавать токены при регистрации пользователей (сигналы Django)

- Использовать готовый эндпоинт obtain_auth_token от DRF

- Создавать защищённые API-эндпоинты с декораторами

- Использовать токены в разных типах клиентов (мобильные приложения, веб-приложения, IoT-устройства)

- Отлаживать проблемы с токенами

— Теперь наш замок имеет полноценную систему пропусков! — с гордостью сказал Винни-Пух. — И всё работает автоматически!

— Но это ещё не предел, — загадочно улыбнулся Филин. — Завтра мы познакомимся с JSON Web Tokens (JWT) — свитками, которые не требуют хранения в базе данных и могут сами рассказывать о себе!

Жители Леса разошлись, обдумывая новые возможности. А автоматическая кузница жетонов тихо работала в фоне, создавая новые пропуска для каждого нового друга, который приходил в их уютный, но теперь хорошо защищённый мир.


# Глава 5 Запечатанные Свитки — Магия JWT
На следующее утро все жители Леса собрались с особым волнением. Филин DRF обещал показать им самое современное и мощное заклинание в мире аутентификации.

— Друзья, — начал Филин торжественно, — сегодня мы познакомимся с JSON Web Tokens (JWT) — или, как я их называю, Запечатанными Свитками. Если обычные токены — это ключи, которые нужно проверять в Книге Учёта, то JWT — это умные свитки, которые сами рассказывают, кто их владелец и что им можно!

— Как это? — удивился Винни-Пух. — Без Книги Учёта? Но как же тогда проверять?

— Магией цифровой подписи! — ответил Филин с таинственной улыбкой. — Но давайте по порядку.

### Что такое JWT?

Филин развернул большой свиток, на котором была нарисована странная строка:

```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsInJvbGUiOiJ1c2VyIn0.4P5NYRoQ9isGqwS8Gb0YvBRtk9dcbG6AzlvEl5jOYz4
```

— Это и есть JWT! — объявил Филин. — Видите три части, разделённые точками? Давайте разберём каждую.

### Часть 1: Заголовок (Header)

```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

— Если расшифровать этот код, внутри написано:

```json
{
  "alg": "HS256",  # Алгоритм шифрования (HMAC SHA-256)
  "typ": "JWT"     # Тип токена
}
```

— Это как конверт письма: на нём написано, какими чернилами и печатью оно запечатано.

### Часть 2: Полезная нагрузка (Payload)

```text
eyJ1c2VyX2lkIjoxMjMsInJvbGUiOiJ1c2VyIn0
```

— Внутри этого кода:

```json
{
  "user_id": 123,    # ID пользователя
  "role": "user",    # Роль пользователя
  "exp": 1700000000  # Срок действия (timestamp)
}
```

— Подожди! — остановил Кролик. — Эта структура всегда такая? user_id, role, exp? И кто это создаёт?

— Отличные вопросы! — похвалил Филин. — Нет, структура может быть любой! JWT стандарт не диктует, какие поля должны быть в payload. Мы сами решаем, что туда положить!

— Кто создаёт payload? — продолжил Филин. — Сервер (наше приложение) создаёт его во время аутентификации пользователя. Мы смотрим: «Ага, это Винни-Пух, его ID 123, он обычный пользователь. Давайте положим эту информацию в свиток!»

— Но есть стандартные поля (claims), которые рекомендуются:

- sub (subject) — кому принадлежит токен (чаще user_id)

- exp (expiration) — срок действия (обязательно!)

- iat (issued at) — когда выдан

- iss (issuer) — кто выдал (название приложения)

— Мы можем добавлять свои поля! — сказал Филин. — Например:

```json
{
  "user_id": 123,
  "username": "winnie",
  "favorite_honey": "липовый",
  "honey_quota": 5,      # Квота мёда в день
  "is_premium": false,
  "exp": 1700000000
}
```

### Часть 3: Подпись (Signature)

```text
4P5NYRoQ9isGqwS8Gb0YvBRtk9dcbG6AzlvEl5jOYz4
```

— А вот это самое интересное! — воскликнул Филин. — Подпись создаётся так:

- Берутся закодированные Header и Payload

- К ним добавляется секретный ключ (который знает только сервер!)

- Всё это шифруется алгоритмом из Header (HS256)

- Получается эта самая строка — подпись

— Если кто-то попробует изменить данные в Header или Payload, подпись перестанет совпадать! — объяснил Филин. — И сервер сразу поймёт, что свиток поддельный.

### Как работает JWT?

— Давайте представим это в виде сказки, — предложил Филин.

- Винни-Пух приходит в замок и говорит: «Я — Винни-Пух, мой пароль — "мёд123"».

- Медведь проверяет логин и пароль. Всё верно!

- Медведь создаёт свиток JWT, куда записывает: «Владелец: Винни-Пух, ID: 123, роль: любитель мёда, срок действия: до завтрашнего полудня».

- Медведь ставит свою волшебную печать (подпись) и отдаёт свиток Винни-Пуху.

- Винни-Пух уходит, но через час возвращается и просто показывает свиток.

- Стража смотрит на свиток, проверяет печать Медведя (совпадает ли подпись), смотрит срок действия (не истёк ли) и пропускает!

— И не нужно заглядывать в Книгу Учёта! — догадался Кролик.

— Точно! — подтвердил Филин. — Свиток самодостаточен. Вся информация уже в нём, а печать гарантирует, что его не подделали.

### Сравнение JWT и обычных токенов

— Давайте сравним на примере, — предложил Филин.

### Обычные токены (вчерашние):

- Токен abc123 хранится в базе данных

- Сервер получает запрос с токеном abc123

- Сервер ищет abc123 в базе

- Находит запись: «Токен abc123 принадлежит Винни-Пуху»

- Сервер пропускает Винни-Пуха

### JWT (сегодняшние):

- Сервер создаёт свиток: header.payload.signature

- В payload записано: {"user_id": 123, "username": "winnie"}

- Сервер отдаёт свиток Винни-Пуху

- Винни-Пух показывает свиток

- Сервер проверяет подпись (печать) — она верна!

- Сервер читает payload — видит: «А, это Винни-Пух!»

- Сервер пропускает Винни-Пуха

— А как отозвать JWT, если он украден? — спросил осторожный Кролик.

— Вот в этом сложность! — признал Филин. — Обычные токены можно просто удалить из базы. С JWT нужно либо:

- Сделать срок жизни очень коротким (например, 15 минут)

- Создать чёрный список украденных токенов

- Поменять секретный ключ (но тогда все существующие токены станут недействительными)

### Когда использовать JWT?

— JWT идеально подходит для: — начал перечислять Филин.

- Одностраничных приложений (SPA) — React, Vue, Angular

- Мобильных приложений — iOS, Android

- Микросервисной архитектуры — когда несколько сервисов общаются друг с другом

— А когда НЕ стоит использовать JWT? — спросил Винни-Пух.

— Когда вам важна возможность мгновенного отзыва доступа, — ответил Филин. — Например, если пользователь сменил пароль, нужно немедленно заблокировать все его старые токены. С JWT это сложнее, чем с токенами в базе.

### Безопасность JWT

— Запомните золотые правила безопасности JWT! — сказал Филин серьёзно.

- Храните секретный ключ в тайне! Если его узнают, смогут создавать поддельные свитки.

- Всегда используйте HTTPS! JWT летает по сети открыто (payload не шифрован). HTTPS шифрует весь трафик.

- Устанавливайте короткие сроки жизни! Чем короче живёт токен, тем меньше шансов, что им воспользуются, если он украден.

- Не храните секреты в payload! Помните — payload читаем всеми!

### Пример JWT на практике

Филин взял чистый свиток и начал писать:

```python
# Пример создания JWT (в псевдокоде)
header = {
    "alg": "HS256",
    "typ": "JWT"
}

payload = {
    "user_id": 123,
    "username": "winnie",
    "role": "honey_lover",
    "exp": 1672531200  # Срок действия: 1 января 2023
}

# Секретный ключ (знает только сервер!)
secret_key = "СУПЕР_СЕКРЕТНЫЙ_КЛЮЧ_МЕДВЕДЯ"

# Создаём подпись
signature = HMACSHA256(
    base64encode(header) + "." + base64encode(payload),
    secret_key
)

# Собираем JWT
jwt_token = base64encode(header) + "." + base64encode(payload) + "." + base64encode(signature)
```

— И этот jwt_token отправляется клиенту в ответе, — закончил Филин. — А клиент потом присылает его в заголовке:

```text
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

— Почему Bearer, а не Token? — спросил Пятачок.

— Bearer — это стандартное название для токенов доступа в OAuth 2.0, — объяснил Филин.

— О! А что такое OAuth? — спросил Винни-Пух.

— OAuth 2.0 — это стандарт авторизации, который позволяет приложениям получать ограниченный доступ к данным пользователя без передачи пароля! — сказал Филин. — Например, когда вы входите на сайт через «Войти через Google» — это OAuth. Google выдаёт сайту токен (часто JWT), который говорит: «Да, это действительно пользователь Google, вот его email, но пароль мы не даём».

— В OAuth токены называются Bearer tokens («токены предъявителя»), — продолжил Филин. — Поэтому для JWT часто используют префикс Bearer. Но технически можно использовать и Token или даже JWT — главное, чтобы сервер понимал.

### Зачем всё это нужно?

— JWT — это следующий шаг в эволюции аутентификации, — сказал Филин. — Они позволяют:

- Создавать статусные (stateless) API, которые не хранят состояние сессий

- Легко масштабировать приложения на множество серверов

- Передавать дополнительную информацию прямо в токене (роли, права, метаданные)

- Интегрироваться с современными фронтенд-фреймворками и мобильными платформами

— Но помните, — предупредил Филин, — JWT — не серебряная пуля. У них есть свои недостатки, и выбирать между обычными токенами и JWT нужно в зависимости от задачи!

— Завтра, — пообещал Филин, собирая свитки, — мы установим и настроим JWT в нашем замке! Вы научитесь создавать эти волшебные свитки и проверять их с помощью библиотеки djangorestframework-simplejwt.

Жители Леса разошлись, обсуждая удивительные возможности запечатанных свитков. Винни-Пух даже попробовал нарисовать свой JWT на берёсте, но почему-то стража не пропустила его по этому рисунку. Видимо, без цифровой подписи не обойтись...


# Глава 6 Установка Волшебной Библиотеки JWT в Замке
На следующий день жители Леса собрались снова, полные ожидания. Вчера они узнали о волшебных запечатанных свитках JWT, а сегодня Филин DRF обещал научить их создавать эти свитки в их собственном замке!

— Друзья! — начал Филин. — Сегодня мы превратим наш замок в настоящую фабрику запечатанных свитков! Мы установим и настроим библиотеку, которая умеет создавать и проверять JWT без лишних хлопот.

### Библиотека djangorestframework-simplejwt

— Для работы с JWT в Django REST Framework существует отличная библиотека — djangorestframework-simplejwt, — объявил Филин, показывая волшебный свиток-документацию. — Она уже содержит всё необходимое:

- Создание JWT при входе пользователя

- Проверку JWT в каждом запросе

- Обновление истёкших токенов

- Настройку времени жизни токенов

— Звучит волшебно! — воскликнул Винни-Пух. — Как её установить?

### Шаг 1: Установка библиотеки

— Очень просто! — ответил Филин. — Открываем волшебную консоль (терминал) и пишем:

```bash
pip install djangorestframework-simplejwt
```

— Всего одна команда! — удивился Пятачок.
— Да! — подтвердил Филин. — Эта команда скачивает библиотеку с волшебного склада PyPI и устанавливает её в наше окружение.

### Шаг 2: Настройка аутентификации в замке

— Теперь нужно сообщить нашему замку, что мы будем использовать JWT для проверки друзей, — сказал Филин, открывая главную книгу законов settings.py.

```python
# settings.py — Главная книга законов замка
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # Указываем, что теперь будем использовать JWT для проверки
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
}
```

— Видите разницу? — спросил Филин. — Раньше у нас было TokenAuthentication, а теперь — JWTAuthentication. Теперь стража будет проверять не простые жетоны, а запечатанные свитки!

### Шаг 3: Создание дверей для получения свитков (urls.py)

— Теперь создадим специальные двери, куда друзья будут приходить за свитками, — продолжил Филин, открывая файл urls.py.

```python
# urls.py — Карта дверей замка
from django.urls import path
from rest_framework_simplejwt.views import (
    TokenObtainPairView,    # Дверь для получения пары токенов
    TokenRefreshView,       # Дверь для обновления токена доступа
)

urlpatterns = [
    # ... другие двери замка ...
    
    # Дверь для получения свитков
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    
    # Дверь для обновления свитков
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
```

— Что такое TokenObtainPairView? — спросил Кролик.

— Это готовое представление (view) из библиотеки simplejwt, которое:

- Принимает POST-запрос с username и password

- Проверяет их

- Если всё правильно — создаёт пару токенов (access и refresh)

- Возвращает их в JSON-ответе

— DRF сам создаёт объект этого класса когда кто-то обращается по URL /api/token/, и сам вызывает нужные методы (в данном случае post()), — объяснил Филин.

— Зачем две двери? — спросил Винни-Пух.

— Отличный вопрос! — похвалил Филин. — В JWT обычно используется два типа токенов:

- Access Token (токен доступа) — короткоживущий (например, 5-15 минут), для доступа к защищённым ресурсам

- Refresh Token (токен обновления) — долгоживущий (например, 1-7 дней), для получения новых access токенов

— Это как в банке! — воскликнул Винни-Пух. — Access Token — это наличные, которые ты тратишь в магазине. Refresh Token — это банковская карта, которой ты получаешь новые наличные, когда старые заканчиваются!

— Именно! — согласился Филин. — TokenObtainPairView выдаёт оба токена, а TokenRefreshView по refresh токену выдаёт новый access токен.

### Шаг 4: Настройка времени жизни свитков

— А как настроить, чтобы access токен жил не 15 минут, а, например, 1 час? — спросил Кролик.

— Очень просто! — ответил Филин. — Добавим в settings.py специальные настройки:

```python
# settings.py
from datetime import timedelta

SIMPLE_JWT = {
    # Access токен живёт 5 минут
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),
    
    # Refresh токен живёт 1 день
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    
    # При каждом обновлении выдавать новый refresh токен
    'ROTATE_REFRESH_TOKENS': True,
    
    # Старые refresh токены добавлять в чёрный список
    'BLACKLIST_AFTER_ROTATION': True,
    
    # Можно настроить и другие параметры:
    'AUTH_HEADER_TYPES': ('Bearer',),  # Тип заголовка
    
    # USER_ID_FIELD и USER_ID_CLAIM — это настройки того,
    # как будет храниться ID пользователя в JWT
    'USER_ID_FIELD': 'id',              # Поле в модели User, которое содержит ID (обычно 'id')
    'USER_ID_CLAIM': 'user_id',         # Название поля в payload JWT, где будет храниться этот ID
    
    # Что это значит? — спросил Пятачок.
    # Это значит, — объяснил Филин, — что в payload JWT будет поле 'user_id',
    # в котором будет значение user.id (например, {"user_id": 123, ...})
}
```

### Шаг 5: Добавление своих данных в свиток

— А можно добавить в свиток дополнительную информацию? — спросил Винни-Пух. — Например, мой любимый сорт мёда?

— Конечно! — ответил Филин. — Для этого нужно создать свой сериализатор.

— Что такое сериализатор? — спросил Пятачок.

— Это волшебное заклинание, которое преобразует данные (например, информацию о пользователе) в формат, который можно положить в свиток JWT, — объяснил Филин. — А TokenObtainPairSerializer — это специальный сериализатор из simplejwt, который умеет создавать JWT токены.

```python
# serializers.py — Волшебные преобразователи
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer

class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    """
    Наш кастомный сериализатор для создания JWT.
    Наследуется от стандартного TokenObtainPairSerializer.
    """
    
    @classmethod
    def get_token(cls, user):
        """
        Этот метод вызывается при создании токена для пользователя.
        """
        # super().get_token(user) вызывает метод get_token родительского класса
        # Родительский метод создаёт стандартный JWT токен с базовыми полями
        # (user_id, exp, iat и другими)
        token = super().get_token(user)
        
        # Как это работает подробно? — спросил Кролик.
        # Когда мы вызываем super().get_token(user), — объяснил Филин, —
        # родительский класс (TokenObtainPairSerializer):
        # 1. Создаёт объект токена (экземпляр класса AccessToken)
        # 2. Добавляет в него стандартные claims: user_id, exp, iat, jti и другие
        # 3. Возвращает этот объект токена
        
        # Теперь мы можем добавить свои поля в payload токена
        token['email'] = user.email
        token['is_superuser'] = user.is_superuser
        token['favorite_honey'] = 'липовый'  # Любимый мёд пользователя
        token['honey_quota'] = 10  # Дневная квота мёда
        
        return token
```

— А когда, где и как создаётся объект этого класса и вызывается его метод? — спросил Винни-Пух.

— Отличный вопрос! — сказал Филин. — DRF делает это автоматически:

- Когда пользователь отправляет POST на /api/token/

- TokenObtainPairView создаёт объект нашего CustomTokenObtainPairSerializer

- Вызывает у него метод validate() (который наследуется от родителя)

- Внутри validate() вызывается наш метод get_token()

- Создаётся JWT с нашими дополнительными полями

— Теперь нужно сказать нашему TokenObtainPairView, чтобы он использовал этот сериализатор, — продолжил Филин. — Для этого создадим своё представление:

```python
# views.py
from rest_framework_simplejwt.views import TokenObtainPairView
from .serializers import CustomTokenObtainPairSerializer

class CustomTokenObtainPairView(TokenObtainPairView):
    """
    Кастомное представление для получения токенов
    с дополнительными данными в payload.
    Наследуется от стандартного TokenObtainPairView.
    """
    serializer_class = CustomTokenObtainPairSerializer
    # Говорим: "Используй наш кастомный сериализатор вместо стандартного!"
```

— И обновим urls.py:

```python
# urls.py
from django.urls import path
from .views import CustomTokenObtainPairView
from rest_framework_simplejwt.views import TokenRefreshView

urlpatterns = [
    path('api/token/', CustomTokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
```

— Теперь, когда Винни-Пух получит токен, в нём будет записано, что его любимый мёд — липовый! — сказал Филин.

### Шаг 6: Тестирование волшебных дверей

— Давайте проверим, как это работает! — предложил Филин.

1. Получение пары токенов:

```bash
# Винни-Пух просит свитки
curl -X POST http://замок-данных.лес/api/token/ \
  -H "Content-Type: application/json" \
  -d '{"username": "winnie", "password": "honey123"}'
```
— Что ответит замок? — спросил Пятачок.

— Если логин и пароль правильные:

```json
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",  # Токен обновления
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."    # Токен доступа
}
```

— А если расшифровать access токен (например, на сайте jwt.io), мы увидим:

```json
{
  "user_id": 123,
  "exp": 1672531200,
  "email": "winnie@forest.com",
  "is_superuser": false,
  "favorite_honey": "липовый",
  "honey_quota": 10
}
```

2. Использование access токена:

— Теперь, когда у Винни-Пуха есть access токен, он может обращаться к защищённым комнатам:

```bash
# Винни-Пух идёт за мёдом
curl -X GET http://замок-данных.лес/api/secret-honey/ \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

— Обратите внимание! — указал Филин. — Используется Bearer, а не Token, как было с обычными токенами!

### Шаг 7: Решение типичных проблем

— А что если что-то пойдёт не так? — спросил осторожный Пятачок.

Филин достал свиток «Справочник волшебника JWT»:

Проблема 1: «JWT token is invalid»

Причина: Токен истёк или был неправильно сгенерирован.

Решение: Используйте refresh токен для получения нового access токена.

Проблема 2: «Token signature is invalid»

Причина: Кто-то изменил токен, или изменился SECRET_KEY в настройках.

Решение: Проверьте, не меняли ли вы SECRET_KEY. Если меняли — все старые токены стали недействительными.

Проблема 3: Неправильный формат заголовка

Причина: Отправлен Authorization: Token ... вместо Authorization: Bearer ...

Решение: Используйте правильный префикс Bearer.

## Итог дня

— Сегодня мы совершили настоящую революцию в нашем замке! — подвёл итог Филин. — Мы:

- Установили библиотеку djangorestframework-simplejwt

- Настроили JWT аутентификацию в settings.py

- Создали эндпоинты для получения и обновления токенов

- Настроили время жизни токенов и объяснили, что такое USER_ID_CLAIM

- Создали кастомный сериализатор и объяснили, как работает TokenObtainPairSerializer

- Научились добавлять свои данные в JWT

— Теперь наш замок использует самые современные технологии аутентификации! — с гордостью сказал Винни-Пух.

— Но и это ещё не всё! — улыбнулся Филин. — Завтра мы научимся использовать JWT для полноценной аутентификации пользователей, создадим систему входа и выхода, и даже реализуем чёрный список токенов!

Жители Леса разошлись, обдумывая возможности, которые открывают перед ними запечатанные свитки JWT. А автоматическая фабрика свитков тихо работала, готовая выдавать волшебные пропуска всем друзьям, которые захотят посетить их уютный, высокотехнологичный замок.


# Глава 7 Мастерская Запечатанных Свитков — Полная Система JWT
Через день жители Леса снова собрались в замке. На этот раз Филин DRF приготовил для них настоящую мастерскую по работе с JWT.

— Друзья! — начал Филин. — Мы уже установили библиотеку и создали базовые эндпоинты для JWT. Но сегодня мы построим полноценную систему аутентификации с запечатанными свитками! Мы научимся не только выдавать их, но и проверять, обновлять и даже отзывать!

### Шаг 1: Настройка проекта для работы с JWT

— Сначала убедимся, что у нас установлена библиотека, — сказал Филин.

```bash
# Если ещё не установлено
pip install djangorestframework-simplejwt
```

— Теперь настроим наш замок в settings.py:

```python
# settings.py
from datetime import timedelta

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=30),  # Access токен живёт 30 минут
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),     # Refresh токен живёт 1 день
    'ROTATE_REFRESH_TOKENS': True,                   # Выдавать новый refresh токен при обновлении
    'BLACKLIST_AFTER_ROTATION': True,                # Добавлять старые refresh токены в чёрный список
    'SIGNING_KEY': 'ВАШ_СЕКРЕТНЫЙ_КЛЮЧ',             # Секретный ключ для подписи
}
```

— Подожди! — остановил Кролик. — Что за SIGNING_KEY? Мы сами должны его придумать? И раньше мы обходились без такого ключа вроде как?

— Отличный вопрос! — сказал Филин. — SIGNING_KEY — это секретный ключ для создания волшебной печати (цифровой подписи) на свитке JWT.

— Раньше, с обычными токенами, мы хранили их в базе данных, — продолжил он. — Когда приходил токен, мы искали его в базе и проверяли: «Есть ли такой токен? Не истёк ли?» А с JWT мы не храним токены в базе — мы проверяем печать (подпись).

— Если кто-то попытается подделать свиток (например, изменить user_id в payload), печать не совпадёт, и мы поймём, что свиток поддельный. А печать создаётся с помощью этого самого SIGNING_KEY!

— Да, мы сами придумываем этот ключ (длинную сложную строку), и никому его не показываем! — подчеркнул Филин. — Если ключ узнают, смогут создавать поддельные свитки!

— А у меня в settings.py уже есть секретный ключ Django! Вот этот:

```python
# Секретный ключ Django (ДОЛЖЕН храниться в .env, НЕ в коде!)
SECRET_KEY = os.environ.get('SECRET_KEY')
if not SECRET_KEY:
    raise ValueError("SECRET_KEY не найден в переменных окружения")
```

— Речь идёт о нём? — спросил Кролик.

— Да! — ответил Филин. — Это тот самый секретный ключ! Библиотека djangorestframework-simplejwt по умолчанию использует SECRET_KEY из настроек Django для подписи JWT. Так что если у тебя уже настроен секретный ключ через переменные окружения — отлично! JWT будет использовать его автоматически, даже если ты не укажешь SIGNING_KEY.

— Но можно и указать свой специальный ключ для JWT, — добавил Филин. — Например, если хочешь, чтобы ключ для подписи JWT отличался от основного ключа Django. Но в большинстве случаев используют один и тот же.

— Как указать свой ключ? — спросил Винни-Пух.
— Очень просто! — ответил Филин. — В настройках SIMPLE_JWT ты указываешь свой ключ:

```python
SIMPLE_JWT = {
    # ... другие настройки ...
    'SIGNING_KEY': 'ОТДЕЛЬНЫЙ_СЕКРЕТНЫЙ_КЛЮЧ_ТОЛЬКО_ДЛЯ_JWT',
}
```

— Но хранить ключ прямо в коде — плохая практика! Лучше использовать переменные окружения. Давайте исправим с помощью библиотеки python-decouple:

```bash
pip install python-decouple
```

— И в settings.py:

```python
from decouple import config

SIMPLE_JWT = {
    # ... другие настройки ...
    'SIGNING_KEY': config('JWT_SECRET_KEY', default=config('SECRET_KEY')),
    # Если есть JWT_SECRET_KEY — используем его, иначе — обычный SECRET_KEY
}
```

— А в файле .env (который НЕ попадает в Git):

```text
SECRET_KEY=ваш_супер_секретный_ключ_никому_не_показывать
JWT_SECRET_KEY=отдельный_ключ_только_для_jwt_если_нужно  # Необязательно
```

### Шаг 2: Эндпоинты для получения и обновления токенов

— Теперь создадим двери, через которые друзья будут получать свитки, — сказал Филин, открывая urls.py.

```python
# urls.py — Карта дверей замка
from django.urls import path
from rest_framework_simplejwt.views import (
    TokenObtainPairView,   # Для получения токенов
    TokenRefreshView,      # Для обновления access токена
)

urlpatterns = [
    # Дверь для получения свитков (логин)
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    
    # Дверь для обновления свитков
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
```
— Давайте протестируем! — предложил Винни-Пух.

### Тест 1: Получение токенов (логин)

```bash
# Винни-Пух логинится
curl -X POST http://замок-данных.лес/api/token/ \
  -H "Content-Type: application/json" \
  -d '{"username": "winnie", "password": "honey123"}'
  ```

Ответ:

```json
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

### Тест 2: Обновление access токена

— Через 30 минут access токен истечёт. Тогда:

```bash
# Винни-Пух обновляет access токен
curl -X POST http://замок-данных.лес/api/token/refresh/ \
  -H "Content-Type: application/json" \
  -d '{"refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}'
  ```

Ответ:

```json
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."  # Новый access токен
}
```

— Подожди! — остановил Пятачок. — В ответе только новый access токен. А если refresh токен тоже обновляется (у нас же стоит ROTATE_REFRESH_TOKENS': True), то как мы его узнаем?

— Ещё один отличный вопрос! — сказал Филин. — Когда стоит ROTATE_REFRESH_TOKENS': True, при каждом обновлении access токена выдаётся и новый refresh токен тоже! Но по умолчанию TokenRefreshView возвращает только access токен.

— Чтобы получить и новый refresh токен, нужно настроить представление по-другому. Но в нашем случае, — продолжил Филин, — мы просто будем знать: старый refresh токен теперь недействителен (попадёт в чёрный список), а новый refresh токен... мы его не получим, пока не залогинимся заново. На практике часто делают отдельный эндпоинт, который возвращает и access, и refresh.

### Шаг 3: Настройка чёрного списка токенов

— Для реализации выхода (logout) нам понадобится чёрный список, — сказал Филин. — Для этого установим дополнительную функцию библиотеки:

```bash
pip install djangorestframework-simplejwt[blacklist]
```

— Добавляем в settings.py:

```python
# settings.py
INSTALLED_APPS = [
    # ... другие приложения ...
    'rest_framework_simplejwt.token_blacklist',  # Для чёрного списка токенов
]
```

— И выполняем миграции:

```bash
python manage.py migrate
```

— А после python manage.py migrate не надо ещё раз применять миграции? — спросил Винни-Пух.

— Нет! — ответил Филин. — Команда python manage.py migrate сама применяет все неприменённые миграции. Она смотрит: «Какие миграции уже применены, а какие нет?» И применяет недостающие. После этой команды база данных готова к работе!

### Шаг 4: Выход из системы (Logout)

— Теперь создадим представление для выхода:

```python
# views.py — Добавляем новую комнату
from rest_framework_simplejwt.tokens import OutstandingToken, BlacklistedToken
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated

class LogoutView(APIView):
    """
    Комната для выхода из системы.
    Добавляет все токены пользователя в чёрный список.
    """
    permission_classes = [IsAuthenticated]  # Только для вошедших!
    
    def post(self, request):
        try:
            # Ищем все активные токены пользователя
            for token in OutstandingToken.objects.filter(user=request.user):
                # Добавляем каждый токен в чёрный список
                BlacklistedToken.objects.create(token=token)
            
            return Response({
                "message": "Вы успешно вышли из системы. Все ваши токены аннулированы!"
            }, status=200)
            
        except Exception as e:
            return Response({"error": str(e)}, status=400)
```

— Добавляем дверь:

```python
# urls.py
from django.urls import path
from .views import LogoutView

urlpatterns = [
    # ... другие пути ...
    path('api/logout/', LogoutView.as_view(), name='logout'),
]
```

— Теперь, когда Винни-Пух захочет выйти:

```bash
curl -X POST http://замок-данных.лес/api/logout/ \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

Ответ:

```json
{
    "message": "Вы успешно вышли из системы. Все ваши токены аннулированы!"
}
```

— И теперь этот access токен и связанный с ним refresh токен не будут работать! — сказал Филин. — Они в чёрном списке!

### Шаг 5: Защита эндпоинтов с помощью JWT

— Теперь создадим защищённую комнату, куда можно попасть только с правильным JWT, — сказал Филин.

```python
# views.py — Чертежи комнат
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

class ProtectedHoneyVaultView(APIView):
    """
    Секретное хранилище мёда.
    Доступно только с правильным JWT!
    """
    permission_classes = [IsAuthenticated]  # Только для аутентифицированных!
    
    def get(self, request):
        # request.user уже содержит пользователя из JWT!
        return Response({
            "message": f"Привет, {request.user.username}!",
            "secret_info": "Здесь хранится 1000 банок липового мёда!",
            "your_user_id": request.user.id
        })
```

— Добавляем дверь:

```python
# urls.py
from django.urls import path
from .views import ProtectedHoneyVaultView

urlpatterns = [
    # ... другие пути ...
    path('api/protected-honey/', ProtectedHoneyVaultView.as_view(), 
         name='protected_honey'),
]
```

### Шаг 6: Кастомизация токенов

— А можно добавить в токен дополнительную информацию? — спросил Винни-Пух. — Например, мою дневную квоту мёда?

— Конечно! — ответил Филин. — Для этого создадим кастомный сериализатор:

```python
# serializers.py — Волшебные преобразователи
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer

class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    """
    Кастомный сериализатор для добавления дополнительных данных в JWT.
    """
    
    @classmethod
    def get_token(cls, user):
        # Получаем стандартный токен от родителя
        token = super().get_token(user)
        
        # Добавляем свои поля
        token['email'] = user.email
        token['is_staff'] = user.is_staff  # Является ли сотрудником замка
        token['daily_honey_quota'] = 10    # Дневная квота мёда
        token['favorite_honey_type'] = 'липовый'  # Любимый сорт
        
        return token
```

— И кастомное представление:

```python
# views.py
from rest_framework_simplejwt.views import TokenObtainPairView
from .serializers import CustomTokenObtainPairSerializer

class CustomTokenObtainPairView(TokenObtainPairView):
    """
    Кастомное представление для получения токенов
    с дополнительными данными.
    """
    serializer_class = CustomTokenObtainPairSerializer
```

— Обновляем urls.py:

```python
# urls.py
from django.urls import path
from .views import CustomTokenObtainPairView, TokenRefreshView

urlpatterns = [
    path('api/token/', CustomTokenObtainPairView.as_view(), 
         name='custom_token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), 
         name='token_refresh'),
]
```

### Шаг 7: Полный цикл тестирования

Давайте протестируем полный цикл:

Логин:

```bash
curl -X POST http://замок-данных.лес/api/token/ \
  -H "Content-Type: application/json" \
  -d '{"username": "winnie", "password": "honey123"}'
```

→ Получаем access и refresh токены.

Доступ к защищённому ресурсу:

```bash
curl -X GET http://замок-данных.лес/api/protected-honey/ \
  -H "Authorization: Bearer ваш_access_токен"
```

→ Получаем секретный мёд.

Обновление токена (через 30 минут):

```bash
curl -X POST http://замок-данных.лес/api/token/refresh/ \
  -H "Content-Type: application/json" \
  -d '{"refresh": "ваш_refresh_токен"}'
```
→ Получаем новый access токен.

Выход:

```bash
curl -X POST http://замок-данных.лес/api/logout/ \
  -H "Authorization: Bearer ваш_access_токен"
```
→ Токены попадают в чёрный список.

Попытка использовать аннулированный токен:

```bash
curl -X GET http://замок-данных.лес/api/protected-honey/ \
  -H "Authorization: Bearer ваш_старый_access_токен"
```
→ Ошибка: "detail": "Токен находится в чёрном списке"

### Шаг 8: Безопасность и лучшие практики

— Запомните важные правила безопасности! — сказал Филин серьёзно.

- Используйте HTTPS всегда! JWT передаётся открыто в заголовках.

- Храните SECRET_KEY в секрете! Никогда не коммитьте его в Git.

- Устанавливайте разумные сроки жизни:

  - Access token: 5-30 минут

  - Refresh token: 1-7 дней

- Используйте чёрный список для мгновенного отзыва токенов.

- Не храните чувствительные данные в payload JWT.

## Итог дня

— Сегодня мы построили полноценную систему аутентификации на JWT! — подвёл итог Филин. — Мы:

- Узнали, что такое SIGNING_KEY и как его настроить (отдельно или использовать SECRET_KEY Django)

- Настроили JWT с безопасным хранением ключей

- Создали эндпоинты для входа, обновления и выхода

- Защитили API-эндпоинты с помощью JWT

- Реализовали систему чёрного списка для отзыва токенов

- Научились добавлять кастомные данные в JWT

- Протестировали полный цикл работы

— Теперь наш замок защищён современной системой аутентификации! — с гордостью сказал Винни-Пух.

— Но безопасность — это не только аутентификация, — сказал Филин. — Аутентификация отвечает на вопрос «Кто ты?», а авторизация — «Что тебе можно?». Завтра мы узнаем о разрешениях (permissions) в DRF — это система, которая определяет, какие комнаты замка доступны каждому другу!

Жители Леса разошлись, довольные новой мощной системой безопасности. Теперь их замок был защищён не просто ключами, а умными запечатанными свитками, которые сами рассказывали, кто их владелец и когда они истекут.


# Глава 8 Волшебные Правила Доступа — Разрешения в DRF
### Создание своих правил (кастомные разрешения)

— А что если готовых правил не хватает? — спросил Винни-Пух. — Например: «Только владелец своей записи может её редактировать»?

— Тогда создаём свои правила! — ответил Филин.

— Кастомное разрешение — это класс, который наследуется от BasePermission и реализует один или два метода:

- has_permission(self, request, view) — проверка на уровне всего представления

- has_object_permission(self, request, view, obj) — проверка на уровне конкретного объекта

— Подожди! — остановил Кролик. — Что принимают эти два метода и как они передаются? И как эти методы вызываются?

— Отличный вопрос! — сказал Филин. — Давайте разберём:

### has_permission(self, request, view):

Что принимает:

- request — объект запроса (содержит пользователя, данные, метод запроса и т.д.)

- view — само представление (APIView или ViewSet), к которому обращаются

Когда вызывается: Вызывается DRF автоматически для КАЖДОГО запроса к представлению

Что проверяет: Проверяет доступ к всему представлению целиком

Пример: «Может ли этот пользователь вообще обращаться к этому эндпоинту?»

has_object_permission(self, request, view, obj):

Что принимает:

- request — объект запроса

- view — представление

- obj — конкретный объект из базы данных (пост, книга, комментарий)

Когда вызывается: Вызывается DRF автоматически только когда нужно проверить доступ к КОНКРЕТНОМУ объекту

Что проверяет: Проверяет доступ к конкретному объекту

Пример: «Может ли этот пользователь редактировать ЭТОТ конкретный пост?»

— DRF сам решает, какой метод вызывать, — продолжил Филин. — Если пользователь работает со списком (например, GET /posts/) — вызывается только has_permission. Если пользователь работает с конкретным объектом (например, DELETE /posts/5/) — вызывается сначала has_permission, а потом has_object_permission для объекта с ID=5.

### Пример 1: Простое кастомное разрешение

— Допустим, мы хотим разрешить доступ только пользователям с подтверждённой почтой:

```python
from rest_framework.permissions import BasePermission

class IsEmailVerified(BasePermission):
    """
    Разрешение позволяет доступ только пользователям
    с подтверждённым email.
    """
    
    def has_permission(self, request, view):
        # Проверяем: пользователь аутентифицирован И email подтверждён
        return bool(
            request.user and 
            request.user.is_authenticated and 
            request.user.is_email_verified  # Наше поле в модели User
        )
```

### Пример 2: Разрешение для владельцев объектов

— Теперь создадим правило: «Только владелец может редактировать свой пост»:

```python
from rest_framework.permissions import BasePermission

class IsOwner(BasePermission):
    """
    Доступ разрешён только владельцам объекта.
    """
    
    def has_object_permission(self, request, view, obj):
        # Проверяем, что объект имеет поле 'user' или 'owner'
        # и оно совпадает с request.user
        return obj.user == request.user
```

— Подожди! — остановил Кролик. — Что это за объект obj, откуда он взялся, кто его передаёт?

— Отличный вопрос! — сказал Филин. — obj — это конкретный объект из базы данных, с которым хочет работать пользователь. Например, конкретный пост, конкретная книга, конкретный комментарий.

— Кто передаёт этот obj? — продолжил он. — DRF (Django REST Framework) сам передаёт его, когда проверяет разрешения на уровне объекта. Когда пользователь хочет, например, удалить пост с ID=5, DRF:

- Находит пост с ID=5 в базе данных

- Создаёт объект этого поста

- Передаёт его в метод has_object_permission всех разрешений

- Проверяет, что все разрешения возвращают True

— Используем это разрешение:

```python
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from .permissions import IsOwner

class PostDetailView(APIView):
    """
    Детали поста. Редактировать может только владелец.
    """
    permission_classes = [IsAuthenticated, IsOwner]
    
    def get_object(self):
        # Получаем объект поста
        return Post.objects.get(pk=self.kwargs['pk'])
    
    def put(self, request, pk):
        post = self.get_object()
        # Проверяем разрешения для этого объекта
        self.check_object_permissions(request, post)
        # Если IsOwner вернул False — будет ошибка 403 Forbidden!
        
        # Редактируем пост...
        return Response({"message": "Пост обновлён!"})
```

— Подожди ещё! — сказал Винни-Пух. — Что делает Post.objects.get(pk=self.kwargs['pk'])? И что такое self.get_object() и self.check_object_permissions(request, post)?

— Давайте разберём по порядку! — сказал Филин.

- Post.objects.get(pk=self.kwargs['pk']):

- Post.objects — это доступ ко всем постам в базе данных

- .get(pk=...) — найти ОДИН пост по первичному ключу (ID)

- self.kwargs['pk'] — это параметр из URL. Если URL был /posts/5/, то pk=5

Итог: «Найди в базе данных пост с ID, который указан в URL»

post = self.get_object():

Это вызов метода get_object(), который мы определили выше

- Он возвращает найденный объект поста

Итог: «Получи объект поста из базы данных»

self.check_object_permissions(request, post):

Это важнейший метод DRF!

- Он берёт все наши разрешения (в нашем случае [IsAuthenticated, IsOwner])

- Для каждого разрешения вызывает has_object_permission(request, self, post)

- Если хоть одно разрешение вернёт False — выбрасывает исключение PermissionDenied (403 Forbidden)

Итог: «Проверь, имеет ли пользователь права на работу с этим конкретным постом»

### Пример 3: Сложное разрешение с несколькими условиями

— А что если: «Администратор ИЛИ владелец»? — спросил Пятачок.

— Легко! — ответил Филин.

```python
from rest_framework.permissions import BasePermission

class IsAdminOrOwner(BasePermission):
    """
    Доступ только для админов или владельцев объекта.
    """
    
    def has_object_permission(self, request, view, obj):
        # Админ ИЛИ владелец
        return request.user.is_staff or obj.user == request.user
```

### Как применяются разрешения?

— Разрешения можно задавать двумя способами, — объяснил Филин.

### Способ 1: В представлениях (APIView)
— Мы только что видели — через атрибут permission_classes.

### Способ 2: В ViewSet (для работы с моделями)
— Это когда у нас есть целый набор операций (список, детали, создание, обновление, удаление).

```python
from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAdminUser
from .models import Book
from .serializers import BookSerializer

class BookViewSet(ModelViewSet):
    """
    Управление книгами в библиотеке.
    Только администраторы могут добавлять/изменять/удалять книги!
    """
    queryset = Book.objects.all()  # Все книги
    serializer_class = BookSerializer  # Как преобразовывать книги
    permission_classes = [IsAdminUser]  # Только админы!
    
    # Примечание: эти разрешения применяются ко ВСЕМ действиям ViewSet!
    # list (список), retrieve (детали), create, update, destroy
```

— А какая разница между APIView и ViewSet? — спросил Винни-Пух.

— Хороший вопрос! — сказал Филин. — Давайте сравним:

APIView (Представление-комната):

- Это отдельная комната с одной или несколькими дверями

- Каждая дверь — отдельный метод (get(), post(), put(), delete())

Пример: Комната «Гостевой журнал» с дверями «Прочитать» (GET) и «Написать» (POST)

Подходит для: Простых эндпоинтов, не связанных с моделями, или кастомной логики

ViewSet (Набор представлений-комнат):

- Это целый набор связанных комнат для работы с одной моделью

- Автоматически создаёт все стандартные операции: список, детали, создание, обновление, удаление

Пример: Набор комнат для книг: «Список книг», «Детали книги», «Добавить книгу», «Изменить книгу», «Удалить книгу»

Подходит для: CRUD операций (Create, Read, Update, Delete) с моделями

— Если просто: APIView — это как отдельная комната с ручным управлением, а ViewSet — как готовый набор комнат для работы с коллекцией предметов, — объяснил Филин.

### Полезные трюки с кастомными разрешениями

— Есть специальная константа SAFE_METHODS, — сказал Филин.

— Что это? — спросил Пятачок.

— SAFE_METHODS — это набор HTTP-методов, которые не изменяют данные на сервере, — объяснил Филин. — К ним относятся: GET, HEAD, OPTIONS. Эти методы только читают данные, но не создают, не изменяют и не удаляют их.

— Методы, которые изменяют данные: POST (создание), PUT и PATCH (изменение), DELETE (удаление).

— Например, правило: «Читать могут все, а изменять — только админы»:

```python
from rest_framework.permissions import BasePermission, SAFE_METHODS

class ReadOnlyOrAdmin(BasePermission):
    """
    Доступ на чтение для всех, но изменения могут делать только админы.
    """
    
    def has_permission(self, request, view):
        # Безопасные методы разрешены всем
        # Опасные методы — только админам
        return bool(
            request.method in SAFE_METHODS or
            request.user and request.user.is_staff
        )
```

— Как это работает? — спросил Винни-Пух.

— Если метод «безопасный» (GET, HEAD, OPTIONS) — доступ разрешён ВСЕМ, — объяснил Филин. — Если метод «опасный» (POST, PUT, PATCH, DELETE) — доступ только АДМИНАМ!

### Тестирование разрешений

— Как проверить, что наши правила работают? — спросил Кролик.
— Нужно протестировать! — ответил Филин.

```python
# tests.py
from django.test import TestCase
from rest_framework.test import APIClient
from django.contrib.auth.models import User

class PermissionTests(TestCase):
    
    def setUp(self):
        self.client = APIClient()
        # Создаём обычного пользователя
        self.user = User.objects.create_user(
            username="testuser", 
            password="password",
            email="test@example.com"
        )
        # Создаём администратора
        self.admin = User.objects.create_superuser(
            username="admin",
            password="adminpass",
            email="admin@example.com"
        )
    
    def test_owner_permission_success(self):
        """Владелец может удалить свой пост"""
        self.client.force_authenticate(user=self.user)
        response = self.client.delete(f"/posts/{self.post.id}/")
        self.assertEqual(response.status_code, 204)  # Успешное удаление
    
    def test_no_permission(self):
        """Чужой пользователь не может удалить пост"""
        another_user = User.objects.create_user(
            username="another", 
            password="password"
        )
        self.client.force_authenticate(user=another_user)
        response = self.client.delete(f"/posts/{self.post.id}/")
        self.assertEqual(response.status_code, 403)  # Forbidden!
```

— Объясни, что здесь происходит! — попросил Винни-Пух.

— Конечно! — сказал Филин. — Давайте разберём тест по частям:

self.client = APIClient():

APIClient — это специальный клиент для тестирования API от DRF

Он умеет отправлять HTTP-запросы (GET, POST, PUT, DELETE) и проверять ответы

Как работает: Создаёт виртуального клиента, который ведёт себя как браузер или Postman

self.client.force_authenticate(user=self.user):

Этот метод принудительно аутентифицирует клиента как указанного пользователя

Он не требует настоящего токена или пароля — просто говорит: «Считай, что этот клиент — этот пользователь»

Как работает: Устанавливает request.user = self.user для всех последующих запросов

response = self.client.delete(f"/posts/{self.post.id}/"):

Отправляет DELETE-запрос на указанный URL

f"/posts/{self.post.id}/" — создаёт строку типа /posts/5/, где 5 — ID поста

Как работает: Отправляет HTTP DELETE запрос к нашему API

self.assertEqual(response.status_code, 204):

Проверяет, что статус код ответа равен 204

204 — «No Content» (успешное удаление, нет содержимого в ответе)

Как работает: Сравнивает фактический статус код с ожидаемым. Если не совпадает — тест падает.

— А что такое response.status_code? — спросил Пятачок.
— Это числовой код статуса HTTP-ответа, — объяснил Филин. — Например:

200 — OK (успех)

201 — Created (успешное создание)

204 — No Content (успешное удаление)

400 — Bad Request (ошибка в запросе)

401 — Unauthorized (не авторизован)

403 — Forbidden (нет прав)

404 — Not Found (не найдено)

### Типичные ошибки при работе с разрешениями

Филин достал свиток «Ошибки новичков»:

- Забыли про аутентификацию

- Поставили IsOwner, но не поставили IsAuthenticated

Решение: Всегда комбинируйте с IsAuthenticated, если нужно проверять владельца

- Не вызываете check_object_permissions

- Написали has_object_permission, но забыли вызвать self.check_object_permissions(request, obj)

Решение: Всегда вызывайте эту проверку для объектов

- Разрешения уровня объекта для списков

- has_object_permission не вызывается для списков (list action)

Решение: Для фильтрации списков используйте get_queryset()


## Итог дня

— Сегодня мы узнали о разрешениях (permissions) — мощном инструменте управления доступом в DRF! — подвёл итог Филин. — Мы:

- Познакомились с готовыми разрешениями DRF

- Научились создавать свои кастомные разрешения

- Узнали разницу между has_permission и has_object_permission

- Узнали разницу между APIView и ViewSet

- Научились комбинировать разрешения

- Узнали про SAFE_METHODS и как их использовать

- Научились тестировать разрешения с помощью APIClient

- Разобрали типичные ошибки

— Теперь мы можем создавать сложные системы доступа! — воскликнул Кролик. — Например: «Только администраторы могут добавлять новые сорта мёда, но каждый может просматривать каталог!»

— Именно! — улыбнулся Филин. — А завтра мы научимся кастомизировать разрешения для представлений — создавать гибкие правила, которые можно менять в зависимости от ситуации!

Жители Леса разошлись, обдумывая, какие правила доступа установить в их замке. Теперь они понимали: мало знать, кто пришёл в гости — важно ещё и решить, что этому гостю можно делать в каждой комнате их уютного, но хорошо защищённого дома.


# Глава 9 Гибкие Правила — Кастомизация Разрешений для Комнат


На следующий день жители Леса собрались с новыми идеями. Вчера они научились создавать правила доступа, но сегодня Филин DRF обещал показать им, как сделать эти правила по-настоящему гибкими.

— Друзья! — начал Филин. — Вчера мы создавали разрешения, которые работают всегда одинаково. Но представьте: в одной комнате мы хотим пускать только друзей с подтверждённой почтой, в другой — только тех, кто зарегистрировался больше месяца назад, в третьей — только тех, у кого в имени нет слова «спам»! Сегодня мы научимся создавать кастомные разрешения, которые можно тонко настраивать под каждую комнату!

**Разрешения в DRF: повторение на пальцах**

— Давайте быстро вспомним, — сказал Филин. — DRF уже даёт нам стандартные правила:

+ **AllowAny**: вообще без фейсконтроля, пускаем всех

+ **IsAuthenticated**: пускаем только зарегистрированных пользователей

+ **IsAdminUser**: внутрь проходят только администраторы

+ **IsAuthenticatedOrReadOnly**: записываться могут только свои, читать — кто угодно

— Но иногда стандартного фейсконтроля недостаточно, — продолжил Филин. — Например, как ограничить доступ только пользователям с определённым статусом? Здесь вступает в дело кастомизация!

**Как работают кастомные разрешения?**

— Кастомные разрешения в DRF — это просто Python-класс, который наследуется от базового класса 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span>, — объяснил Филин. — Этот класс обязан реализовать метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
has_permission()</span> или <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
has_object_permission()</span>.

— Подожди, — остановил Кролик. — Ты сказал "обязан реализовать". А сам класс 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span> имеет ещё какие-то методы? Или он совершенно пустой?

— Отличный вопрос, Кролик! — похвалил Филин. — Давайте заглянем "под капот"! Класс 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span> на самом деле очень простой. Вот как он выглядит в исходном 
коде DRF:

```python
class BasePermission(metaclass=BasePermissionMetaclass):
    """
    Базовый класс, от которого должны наследоваться все классы разрешений.
    """

    def has_permission(self, request, view):
        """
        Возвращает True, если доступ разрешен, False в противном случае.
        """
        return True

    def has_object_permission(self, request, view, obj):
        """
        Возвращает True, если доступ к объекту разрешен, False в противном случае.
        """
        return True
```
— Видишь? — продолжил Филин. — В классе 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span> уже есть оба метода, но они просто возвращают 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
True</span>! 
То есть по умолчанию разрешение ВСЕГДА разрешает доступ.

— Подожди-подожди! — остановил Кролик, прищурившись. — Я вижу странную штуку в 
первой строке: 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
class BasePermission(metaclass=BasePermissionMetaclass)</span>. 
Что такое <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
metaclass</span>? И что за <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermissionMetaclass</span>? 
Это же не обычное наследование!

— О-о-о! — восхищённо воскликнул Филин. — Кролик, ты задал вопрос продвинутого 
уровня! Это касается магии метаклассов в **Python**!

— **Метакласс** — это "класс классов". Если обычный класс создаёт объекты, то метакласс создаёт классы! — начал объяснять Филин, видя, что все смотрят на него с недоумением.

— Давайте проще: представьте, что у нас есть фабрика по производству стульев.

+ **Объект** — это конкретный стул

+ **Класс** — это чертёж стула

+ **Метакласс** — это фабрика, которая производит чертежи стульев!

— В нашем случае:

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">BasePermissionMetaclass</span> — это фабрика

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">BasePermission</span> — это чертёж, созданный этой фабрикой

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">IsEmailVerified</span> (наш класс) — это конкретный стул, сделанный по чертежу

— Зачем это нужно? — спросил Пятачок.

— Метаклассы позволяют делать волшебные вещи при создании классов! — ответил Филин. 
— Например, <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermissionMetaclass</span> следит за тем, чтобы все классы разрешений правильно 
работали с **DRF**. Это как инспектор, который проверяет все чертежи стульев на фабрике!

— Но нам, обычным разработчикам, не нужно об этом думать! — добавил Филин. — 
Мы просто наследуемся от <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span> и **DRF** делает всю магию за нас!

— Когда мы создаём свой класс и наследуемся от <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span>, мы должны **переопределить (override)** один или оба этих метода, чтобы добавить свою логику проверки. Если мы не переопределим методы — наше разрешение будет всегда разрешать доступ, что нам не нужно!

— А зачем тогда вообще этот базовый класс? — спросил Пятачок.

— Хороший вопрос! — сказал Филин. — Базовый класс даёт нам:

1. **Стандартный интерфейс** — все знают, что у разрешения должны быть методы 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
has_permission()</span> и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
has_object_permission()</span>

2. **Удобство** — нам не нужно каждый раз писать с нуля весь класс

3. **Совместимость** — DRF знает, как работать с любым классом, который наследуется 
от <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span>

— Это как стандартная форма для всех стражников! — сказал Винни-Пух. — У каждого может быть своя униформа, но все носят знак королевской охраны!

— Точно! — улыбнулся Филин. — И этот "знак" — наследование от 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span>!

**Создаём первое кастомное разрешение**

— Начнём с простого, — предложил Филин. — Создадим кастомное разрешение, которое будет допускать к эндпоинту только пользователей с подтверждённой электронной почтой.

```python
# permissions.py — файл с нашими правилами
from rest_framework.permissions import BasePermission

class IsEmailVerified(BasePermission):
    """
    Разрешение позволяет доступ только пользователям с подтверждённым email.
    """
    
    def has_permission(self, request, view):
        # Берем пользователя из запроса и проверяем, подтвержден ли его email
        return bool(
            request.user and 
            request.user.is_authenticated and 
            request.user.is_email_verified  # Наше воображаемое поле
        )
```

— Подождите! — перебил Кролик. — Я вижу здесь 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_authenticated</span> и какое-то странное поле 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_email_verified</span>. Разве эти поля есть в обычном пользователе? Нам их нужно создавать в модели?

— Отличный вопрос, Кролик! — похвалил Филин. — Ты прав, здесь есть важный нюанс!

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_authenticated</span> — это не поле в базе данных! Это специальное *свойство*
**(property)**, которое **Django** добавляет к каждому объекту пользователя. 
Оно автоматически становится 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
True</span>, если пользователь вошёл в систему (аутентифицирован), и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
False</span>, если это анонимный гость. Так что его создавать не нужно — оно уже есть!

— А вот 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_email_verified</span>... — Филин задумался. — Да, это уже наше собственное, 
воображаемое поле. В стандартной модели пользователя от **Django** такого поля нет. 
Если мы хотим проверять подтверждение **email**, нам действительно нужно:

1. Создать свою модель пользователя, которая наследуется от стандартной.

2. Добавить в неё поле 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_email_verified = models.BooleanField(default=False)</span>.

3. Написать логику, которая будет ставить 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
True</span> 
после подтверждения по ссылке из письма.

— Но для нашего учебного примера, — добавил Филин, — мы просто представим, что такое поле существует. В реальном проекте ты бы его добавил сам!

**Подключаем разрешение в представлении**

— Теперь подключим наше новое разрешение к какой-нибудь API-комнате. Но сначала давайте разберемся, что такое представление вообще, — сказал Филин.

```python
# views.py — чертежи комнат
from rest_framework.views import APIView
from rest_framework.response import Response
from .permissions import IsEmailVerified

class VerifiedUserView(APIView):
    """
    Комната только для пользователей с подтверждённым email.
    """
    permission_classes = [IsEmailVerified]  # Используем наше кастомное правило!
    
    def get(self, request):
        return Response({"message": "Вы прошли в суперсекретный клуб!"})
```

— Стоп! — остановил Винни-Пух. — Ты упомянул 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span> . 
Что это такое? И почему в конце класса есть метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get</span>? 
Это как-то связано с **HTTP**?

— Отличные вопросы, Винни-Пух! — обрадовался Филин. — Давайте разберемся с основами,
потому что это фундамент всего **API**!

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span>
— это самый простой и базовый тип "комнаты" (представления) в **DRF**. 
Представь его как голую комнату с четырьмя стенами, полом и потолком, но без мебели.

— Когда ты создаёшь класс и наследуешься от 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span>, 
ты говоришь **Django**: "Я хочу создать эндпоинт (точку входа) в моё **API**". 
Но! Тебе нужно САМОМУ описать, что будет происходить при каждом типе запроса.

— Смотри, — продолжил Филин, — когда к твоему **API** приходит **HTTP**-запрос, 
**Django** смотрит:

+ Если запрос 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
GET</span>
→ ищет метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
def get()</span>
в твоём классе

+ Если запрос
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
POST</span>
→ ищет метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
def post()</span>

+ Если запрос
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
PUT</span>
→ ищет метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
def put()</span>

+ Если запрос
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
DELETE</span>
→ ищет метод
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
def delete()</span>

— В нашем примере 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
VerifiedUserView</span>:

1. Мы наследуемся от 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span>
— это наша "голая комната"

2. Мы добавляем 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
permission_classes = [IsEmailVerified]</span>
— это наш "фейсконтроль"

3. Мы пишем 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
def get(self, request)</span>
— это означает: "Когда приходит **GET**-запрос, сделай вот это"

— И что же происходит? — спросил Пятачок.

— Когда кто-то делает **GET**-запрос к нашей комнате, — объяснил Филин, — 
сначала проверяется разрешение 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsEmailVerified</span>. 
Если **email** не подтверждён — сразу возвращается ошибка **403 Forbidden**. 
Если подтверждён — выполняется метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get()</span>, 
который возвращает радостное сообщение!

— А если мы хотим принимать ещё и **POST**-запросы? — спросил Кролик.

— Тогда нам нужно добавить в класс метод
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
def post(self, request)</span>! 
— ответил Филин. — И так для каждого типа запросов, которые мы хотим поддерживать.

— Но это же неудобно! — воскликнул Винни-Пух. — Если у меня много разных операций, мне придётся писать много методов!

— Именно поэтому существует
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span>! 
— улыбнулся Филин. — Но давайте сначала закончим с основами. 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView </span> 
 — это фундамент. Когда тебе нужна какая-то нестандартная логика, ты используешь 
именно его.

— А теперь представьте более сложный пример, — продолжил Филин.

**Проверка разрешений на уровне объектов**

— Иногда нужно ограничить доступ не только в целом, но и к конкретным записям, — сказал Филин. — Например, разрешить пользователю редактировать только свои комментарии.

— Для этого создадим разрешение, которое позволяет редактировать только свои записи:

```python
# permissions.py — добавляем новое правило
from rest_framework.permissions import BasePermission

class IsOwner(BasePermission):
    """
    Доступ разрешён только владельцам объекта.
    """
    
    def has_object_permission(self, request, view, obj):
        # Проверяем, что объект имеет поле user, и оно совпадает с request.user
        return obj.user == request.user
```

— Я не понял! — признался Кролик. — Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
obj.user</span>? 
Это как автор объекта? Как поста, статьи или комментария?

— Совершенно верно, Кролик! — подтвердил Филин. — Давай представим на реальном примере.

— Допустим, у нас есть модель 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Post</span>
(Пост/Запись) в блоге. Она могла бы выглядеть так:

```python
# models.py
from django.db import models
from django.contrib.auth.models import User

class Post(models.Model):
    title = models.CharField(max_length=200)  # Заголовок
    content = models.TextField()              # Текст поста
    user = models.ForeignKey(User, on_delete=models.CASCADE)  # АВТОР поста
    created_at = models.DateTimeField(auto_now_add=True)
```

— Видишь поле 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
user</span>? 
Это связь с моделью пользователя. Она говорит: «Каждый пост принадлежит какому-то конкретному пользователю — его автору».

— Теперь в разрешении 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOwner</span>:

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">obj</span>
— это конкретный объект пост, к которому пытаются получить доступ (например, пост с **ID=5**).

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">obj.user</span>
— это автор этого поста (объект пользователя).

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">request.user</span>
— это пользователь, который СЕЙЧАС делает запрос.

— И правило 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
return obj.user == request.user проверяет</span>: 
«А тот, кто пытается изменить пост — это тот же самый человек, который его создал?» Если да — разрешаем доступ. Если нет — запрещаем!

— То есть, если я написал пост про мёд, — сказал Винни-Пух, — то только я могу его редактировать. А Пятачок — нет, даже если он мой лучший друг?

— Именно! — подтвердил Филин. — Пятачок сможет только читать твой пост (если мы разрешим чтение всем), но не сможет его изменить или удалить. Это и есть безопасность на уровне объектов!

— Но как это всё связано с 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span>? — спросил Пятачок.

— А вот сейчас мы и перейдём к более продвинутым "комнатам"! — сказал Филин. — Потому что 
писать для каждой модели отдельные 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span>
с методами
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
post</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
put</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
delete</span> 
— это долго и скучно. Для стандартных операций есть готовая мебель — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span>!

**Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span> и как он работает?**

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span>
— это как готовый мебельный гарнитур для твоей комнаты! — начал объяснять Филин. — Представь: 
ты заказываешь "Спальня-стандарт", и тебе привозят кровать, тумбочки, шкаф — 
всё уже на своих местах!

— Давайте создадим простой пример, чтобы понять, — предложил Филин.

— Сначала создадим модель 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Toy</span> (Игрушка):

```python
# models.py
from django.db import models

class Toy(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)
```

— Теперь создадим для неё сериализатор (преобразователь):

```python
# serializers.py
from rest_framework import serializers
from .models import Toy

class ToySerializer(serializers.ModelSerializer):
    class Meta:
        model = Toy  # Какая модель
        fields = ['id', 'name', 'description', 'price', 'created_at']  # Какие поля
```

— И вот самое интересное — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>:

```python
# views.py
from rest_framework.viewsets import ModelViewSet
from .models import Toy
from .serializers import ToySerializer

class ToyViewSet(ModelViewSet):
    """
    Все операции с игрушками в ОДНОМ классе!
    """
    queryset = Toy.objects.all()  # Все игрушки из базы
    serializer_class = ToySerializer  # Как преобразовывать игрушки
```

— Подожди! — остановил Винни-Пух. — И всё? Всего 3 строчки?

— Да! — улыбнулся Филин. — Всего 3 строчки, и у тебя готов полноценный **API** для работы 
с игрушками!

— Но как это работает? — спросил Пятачок.

— Магия 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span>
в том, что он АВТОМАТИЧЕСКИ создаёт все необходимые методы! — объяснил 
Филин. — Когда ты пишешь эти 3 строчки, "под капотом" создаётся примерно такой код:

```python
# ModelViewSet автоматически создаёт ВСЁ это:
class ToyViewSet(ModelViewSet):
    queryset = Toy.objects.all()
    serializer_class = ToySerializer
    
    # АВТОМАТИЧЕСКИ СОЗДАЁТСЯ:
    def list(self, request):
        """GET /toys/ - список всех игрушек"""
        toys = self.get_queryset()  # Берёт все игрушки
        serializer = self.get_serializer(toys, many=True)  # Преобразует в JSON
        return Response(serializer.data)
```

— Подожди! — остановил Кролик. — Я вижу здесь метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
list</span>. Что он делает? И что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.get_queryset()</span>?

— Отличные вопросы! — сказал Филин. — Давайте разберем первый метод:

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
list(self, request)</span>
— этот метод вызывается, когда пользователь делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
GET</span>-запрос к адресу 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/toys/</span> (без указания **ID** конкретной игрушки). Его задача — вернуть список ВСЕХ игрушек.

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.get_queryset()</span>
— это встроенный метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>
, который возвращает набор данных для работы. В нашем случае это 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Toy.objects.all()</span>
— то есть все игрушки из базы данных.

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.get_serializer(toys, many=True)</span>
— это фабрика, которая создаёт сериализатор. Параметр 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
many=True</span>
говорит: "Преобразуй не один объект, а целый список объектов!"

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Response(serializer.data)</span>
— упаковывает результат в **HTTP**-ответ.

— Стоп! — остановил Винни-Пух. — Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
.data в serializer.data</span>? 
Это какое-то свойство?

— Отличный вопрос! — сказал Филин. — Когда сериализатор обрабатывает данные, он создаёт 
специальный объект, у которого есть свойство 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
.data</span>. Это свойство содержит уже преобразованные, готовые данные!

— Представь, что сериализатор — это фабрика по производству конфет:

1. На входе — сырые ингредиенты (объекты из базы данных)

2. Фабрика обрабатывает их (сериализует)

3. На выходе — красиво упакованные конфеты (свойство 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
.data</span>)

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
serializer.data</span>
— это уже полностью готовые к отправке данные в формате, 
понятном для **API** (обычно **JSON**). Это не просто словарь **Python**, а специальная структура, 
которую **DRF** умеет правильно преобразовывать в **HTTP**-ответ.

— Понятно! — сказал Винни-Пух. — Значит, когда я иду по адресу 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/toys/</span>, 
я получаю список всех игрушек в **JSON**-формате?

— Именно! — подтвердил Филин. — Давайте смотрим дальше:

```python
    def retrieve(self, request, pk=None):
        """GET /toys/5/ - одна игрушка с ID=5"""
        toy = self.get_object()  # Находит игрушку по ID
        serializer = self.get_serializer(toy)  # Преобразует в JSON
        return Response(serializer.data)
```

— А это что? — спросил Пятачок.

— Это метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
retrieve</span>
— он вызывается, когда пользователь делает **GET**-запрос к адресу 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/toys/5/</span>
(с указанием **ID=5**). Его задача — вернуть ОДНУ конкретную игрушку.


— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.get_object()</span>
— это умный метод, который:

1. Берёт 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
pk </span>
(**primary key**) из **URL** (в нашем случае 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
5</span>)

2. Ищет объект в базе данных по этому **ID**

3. Если находит — возвращает его

4. Если не находит — автоматически возвращает ошибку **404 "Не найдено"**

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.get_serializer(toy)</span>
— создаёт сериализатор для одного объекта (без 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
many=True</span>)

— То есть, если я хочу получить информацию об игрушке номер **5**, я иду на 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/toys/5/</span>? — уточнил Винни-Пух.

— Совершенно верно! — сказал Филин. — Переходим к следующему методу:

```python
    def create(self, request):
        """POST /toys/ - создать новую игрушку"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)  # Проверяет данные
        serializer.save()  # Сохраняет в базу
        return Response(serializer.data, status=201)
```

— Ой! — запищал Пятачок. — Здесь уже сложнее! Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
request.data</span>? 
И что делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_valid</span>?

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
create</span>
— это метод для создания новых объектов. Он вызывается при **POST**-запросе на 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/toys/</span>.

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.get_serializer(data=request.data)</span>
— создаёт сериализатор, передавая ему данные из запроса. 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
request.data</span>
— это словарь с данными, которые пришли в теле запроса (например, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
{"name": "Медвежонок", "price": "100"}</span>).

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
serializer.is_valid(raise_exception=True)</span>
— проверяет, правильные ли данные пришли. Например, если поле 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
name</span>
обязательное, а его 
нет в данных — будет ошибка. Параметр 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
raise_exception=True</span>
означает: "Если данные неправильные, сразу выбрось исключение" (**DRF** превратит его в 
красивую ошибку **400**).

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
serializer.save()</span>
— сохраняет новый объект в базу данных.

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Response(serializer.data, status=201)</span>
— возвращает данные созданного объекта со статусом **201 "Создано"** (вместо обычного **200 "OK"**).

— Я начинаю понимать! — сказал Кролик. — А что с изменением объектов?

— Для изменения есть два метода, — ответил Филин:

```python
    def update(self, request, pk=None):
        """PUT /toys/5/ - полностью заменить игрушку с ID=5"""
        toy = self.get_object()
        serializer = self.get_serializer(toy, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
```

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
update</span>
— вызывается при **PUT**-запросе на 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/toys/5/</span>. Он ПОЛНОСТЬЮ заменяет объект новыми данными.

— Обрати внимание: 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.get_serializer(toy, data=request.data)

— здесь мы передаём и объект 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
toy</span>
(который нужно изменить), И новые данные 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
data=request.data</span>. Это значит: "Обнови объект 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
toy</span> данными из запроса".

— А если я хочу изменить только цену, а не все поля? — спросил Винни-Пух.

— Для этого есть отдельный метод:

```python
    def partial_update(self, request, pk=None):
        """PATCH /toys/5/ - частично изменить игрушку с ID=5"""
        toy = self.get_object()
        serializer = self.get_serializer(toy, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
```

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
partial_update</span>
— вызывается при **PATCH**-запросе. Ключевое отличие — параметр 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
partial=True</span>! 
Он говорит сериализатору: "Не требуй все обязательные поля, обработай только те, что пришли 
в запросе".

— То есть для **PATCH** я могу отправить только 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
{"price": "150"}</span>, 
а для **PUT** нужно отправлять ВСЕ поля игрушки? — уточнил Кролик.

— Точно! — подтвердил Филин. — И последний метод:

```python
    def destroy(self, request, pk=None):
        """DELETE /toys/5/ - удалить игрушку с ID=5"""
        toy = self.get_object()
        toy.delete()  # Удаляет из базы
        return Response(status=204)
```

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
destroy</span>
— вызывается при **DELETE**-запросе на 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/toys/5/</span>. Он просто находит объект и удаляет его из базы.

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Response(status=204)</span>
— возвращает пустой ответ со статусом **204 "Нет содержимого"** (удаление прошло успешно, но 
возвращать нечего).

— Ух ты! — воскликнул Винни-Пух. — Значит, когда я пишу просто 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span>, **DRF** сам создаёт все эти большие методы?

— Именно! — подтвердил Филин. — Тебе не нужно писать всё это вручную! Ты просто говоришь: 
«Вот модель, вот сериализатор», а **DRF** делает всё остальное!

— Но как **Django** понимает, куда отправлять запросы? — спросил Винни-Пух. — Где говорится, 
что 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
GET /toys/</span>
должен вызывать 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
list()</span>, а 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
GET /toys/5/</span> — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
retrieve()</span>?

— А вот для этого нужны **URL**! — сказал Филин. — И здесь начинается ещё одна магия **DRF**
— роутеры!

**Магия URL: как ModelViewSet связывается с адресами**

— В обычном **Django** мы бы писали в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
urls.py</span>
что-то вроде:

```python
from django.urls import path
from .views import toy_list, toy_detail  # Отдельные функции для каждого действия

urlpatterns = [
    path('toys/', toy_list),  # Для списка
    path('toys/<int:pk>/', toy_detail),  # Для конкретной игрушки
]
```

— Но для 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>
это неудобно — у нас один класс, а не много функций! Поэтому **DRF** придумал роутеры, — 
объяснил Филин.

— Смотрите, как это работает:

```python
# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ToyViewSet

router = DefaultRouter()
router.register(r'toys', ToyViewSet)  # Регистрируем ViewSet

urlpatterns = [
    path('api/', include(router.urls)),  # Включаем все URL
]
```

— Подожди-подожди! — остановил Кролик. — Я ничего не понял! Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
DefaultRouter()</span>? И что делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
router.register()</span>? Объясни подробнее!

— Конечно! — терпеливо ответил Филин. — Давайте разберем по строчкам.

<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
router = DefaultRouter()</span>
— мы создаём объект "маршрутизатора". Представь его как диспетчера на входе в большой 
офисный центр. У него есть список всех комнат 
(
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>) и он знает, куда кого направлять.

<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">router.register(r'toys', ToyViewSet)</span>
— это самая важная строчка! Здесь мы говорим роутеру:

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">r'toys'</span> — "используй префикс 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
toys</span> в URL"

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">ToyViewSet</span>
— "вот класс, который обрабатывает запросы"

— А что означает буква 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
r</span> перед строкой? — спросил Пятачок.

— 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
r'toys'</span> означает "сырая строка" (**raw string**), — объяснил Филин. — 
В **Python** обратный слэш 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px"> \ </span>
имеет особое значение. Например, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
\n</span>
означает перенос строки. А в **URL** часто используются слэши. Чтобы **Python** не пытался понять 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
\t</span> в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
'toys'</span> как символ табуляции, мы пишем 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
r'toys'</span> — это значит "обрабатывай строку как есть, без специальных символов".

— И что происходит дальше? — спросил Винни-Пух.

— Когда мы вызываем 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
router.register()</span>, роутер делает вот что:

1. Берет 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ToyViewSet</span>
и смотрит, какие действия (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
actions</span>) он поддерживает (это 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
list</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
retrieve</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
create</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
update</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
partial_update</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
destroy</span>)

2. Для каждого действия создаёт соответствующий **URL**:
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
toys/</span> → 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
list</span> (**GET**) и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
create</span> (**POST**)
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
toys/{pk}/</span> → 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
retrieve</span> (**GET**), 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
update</span> (**PUT**), 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
partial_update</span> (**PATCH**), 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
destroy</span> (**DELETE**)


3. <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">path('api/', include(router.urls))</span>
— а здесь мы говорим **Django**:

+ "Все URL, которые сгенерировал роутер, размести под префиксом
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
api/</span>"

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">include(router.urls)</span> — значит "включи сюда ВСЕ **URL** из роутера"

— В итоге автоматически создаются такие **URL**:
+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">GET /api/toys/</span> → список всех игрушек
+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">POST /api/toys/</span> → создать новую игрушку
+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">GET /api/toys/5/</span> → получить игрушку с ID=5
+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">PUT /api/toys/5/</span> → полностью заменить игрушку с ID=5
+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">PATCH /api/toys/5/</span> → частично изменить игрушку с ID=5
+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">DELETE /api/toys/5/</span> → удалить игрушку с ID=5

— Вот это магия! — восхитился Пятачок.

— Не магия, а умная разработка! — улыбнулся Филин. — Роутеры экономят кучу времени и исключают 
ошибки в **URL**!

**Подключаем разрешения в ViewSet**

— Теперь вернёмся к нашим разрешениям, — сказал Филин. — Помните разрешение 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOwner</span>, которое мы создали? Давайте применим его в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span> для комментариев.

```python
# views.py
from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from .models import Comment
from .serializers import CommentSerializer
from .permissions import IsOwner

class CommentViewSet(ModelViewSet):
    """
    Управление комментариями.
    Читать могут все, изменять — только владельцы.
    """
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer
    
    def get_permissions(self):
        """
        Динамически меняем разрешения в зависимости от действия.
        """
        # Для методов, изменяющих объект (update, partial_update, destroy)
        # проверяем, что пользователь — владелец
        if self.action in ['update', 'partial_update', 'destroy']:
            return [IsAuthenticated(), IsOwner()]
        # Для остальных методов (list, retrieve, create) достаточно аутентификации
        return [IsAuthenticated()]
```

— Ой! — запищал Пятачок. — Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.action</span>? И почему для одних действий одни правила, а для других — другие?

<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
— self.action</span> 
— это волшебная переменная, которую 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span> сам заполняет в зависимости от того, какое 
действие выполняется! — объяснил Филин. — Когда пользователь:

+ Делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
GET /comments/</span> — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.action = 'list'</span> (список всех)

+ Делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
GET /comments/5/</span> — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.action = 'retrieve'</span> (получить один)

+ Делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
POST /comments/</span> — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.action = 'create'</span> (создать новый)

+ Делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
PUT /comments/5/ — self.action = 'update'</span> (изменить)

+ Делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
DELETE /comments/5/</span> — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.action = 'destroy'</span> (удалить)

— В нашем коде мы говорим: «Для изменения и удаления (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
update</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
destroy</span>) нужна не просто аутентификация, но и проверка, что пользователь — владелец! А для просмотра и создания — достаточно просто войти в систему».

— Подожди! — остановил Кролик. — Я вижу здесь 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
return [IsAuthenticated(), IsOwner()]</span>. 
Почему здесь скобки? 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsAuthenticated</span> и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOwner</span> — это же классы, а не функции! Зачем мы их вызываем как функции?

— Отличнейший вопрос, Кролик! — восхитился Филин. — Ты подметил очень важную деталь!

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">IsAuthenticated</span> и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOwner</span> — это действительно классы. Но когда мы пишем 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsAuthenticated()</span> со скобками — мы создаём экземпляр (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
instance</span>) этого класса!

— Представь, что класс — это чертёж дома, а экземпляр — это построенный по этому чертежу 
реальный дом.

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">IsAuthenticated</span> — это чертёж стража

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">IsAuthenticated()</span> — это реальный страж, стоящий на посту

— **DRF** ожидает получить не чертёж, а реального стража! Поэтому мы должны создать 
экземпляр класса, вызвав его со скобками.

— Но почему тогда в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
permission_classes = [IsEmailVerified]</span> мы не ставим скобки? — спросил Винни-Пух.

— Ещё лучше! — сказал Филин. — В 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
permission_classes</span> **DRF** сам создаёт экземпляры! Ты просто передаёшь классы, а **DRF**
сам их "оживляет". А вот в методе 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get_permissions()</span> ты должен вернуть уже готовые, "оживлённые" объекты!

— Это как разница между:

+ "Пришлите мне чертёж стража" (**DRF** сам построит стража)

+ "Пришлите мне готового стража" (ты должен сам построить и прислать)

— Понятно! — сказал Кролик. — В 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
permission_classes</span> **DRF** сам вызывает наши классы, а в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get_permissions()</span> мы должны вызвать их сами!

— Точно! — подтвердил Филин. — Обычно используют 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
permission_classes</span>, но если нужна сложная логика (как у нас — разные разрешения для разных 
действий), то используют 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get_permissions()</span>.

— Но как система узнает, кто владелец комментария? — спросил Кролик.

— Помнишь разрешение 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOwner</span>? Оно проверяет 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
obj.user == request.user</span>! — напомнил Филин. — Когда пользователь пытается изменить комментарий 
с 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ID=5</span>, система:

1. Находит этот комментарий в базе

2. Передаёт его в разрешение 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOwner</span> как параметр 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
obj</span>

3. <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">IsOwner</span> сравнивает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
obj.user</span> (автор комментария) с 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
request.user</span> (кто делает запрос)

4. Если это один и тот же человек — разрешает доступ

**Тестируем наши кастомные разрешения**

— Чтобы убедиться в корректной работе кастомных разрешений, важно протестировать их, — 
сказал Филин. — Давайте напишем тесты, но сначала разберемся, как вообще пишутся тесты 
в **Django**.

```python
# tests.py — тестирование наших правил
from django.test import TestCase
from rest_framework.test import APIClient
from django.contrib.auth.models import User
from .models import Post

class PermissionTests(TestCase):
    
    def setUp(self):
        """
        Этот метод запускается ПЕРЕД КАЖДЫМ тестом.
        Здесь мы готовим все необходимые данные.
        """
        # Создаём тестового клиента - он умеет отправлять HTTP-запросы
        self.client = APIClient()
        
        # Создаём обычного пользователя
        self.user = User.objects.create_user(
            username="testuser",
            password="password",
            email="test@example.com"
        )
```

— Стоп! — сказал Пятачок. — Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
setUp</span>? И зачем нам 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIClient</span>?

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
setUp</span> — это специальный метод, который **Django** запускает автоматически перед КАЖДЫМ тестом 
в классе, — объяснил Филин. — Он нужен, чтобы подготовить чистые, одинаковые условия для 
каждого теста. Представь, что перед каждым экспериментом ты моешь пробирки и готовишь 
свежие ингредиенты!

— А 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIClient</span> — это специальный тестовый клиент от **DRF**. Он умеет:

+ Отправлять запросы к нашему **API** (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
post</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
put</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
delete</span>)

+ Авторизовываться как разные пользователи (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
force_authenticate</span>)

+ Проверять ответы

— Это как бы виртуальный браузер для тестов! — добавил Филин.

— Продолжим подготовку, — сказал он, показывая следующий код.

python
        # Создаём администратора
        self.admin = User.objects.create_superuser(
            username="admin",
            password="adminpass",
            email="admin@example.com"
        )
        
        # Создаём тестовый пост
        self.post = Post.objects.create(
            title="Test Post",
            content="Some content",
            user=self.user  # Пост принадлежит обычному пользователю
        )
— Теперь у нас есть:

1. Обычный пользователь (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.user</span>)

2. Администратор (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.admin</span>)

3. Тестовый пост, который создал обычный пользователь (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.post</span>)

— А откуда взялась модель 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Post</span>? — спросил Кролик. — Мы же не создавали её в этой главе!

— Правильно заметил! — сказал Филин. — В этом примере я предположил, что у нас уже есть модель 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Post</span> где-то в проекте. В реальном тесте тебе нужно:

1. Создать модель 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
Post</span> в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
models.py</span>

2. Сделать миграции

3. Импортировать её в тест

— Но в тестах ведь мы не хотим портить настоящую базу данных! — испугался Пятачок.

— И не портим! — успокоил Филин. — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
TestCase</span> создаёт временную тестовую базу данных, которая удаляется после всех тестов. 
Настоящая база остаётся нетронутой!

— Теперь перейдём к самим тестам. Давайте разберём их по одному, — предложил Филин.

```python
    def test_owner_permission_success(self):
        """Владелец может удалить свой пост"""
        # Аутентифицируем как владельца
        self.client.force_authenticate(user=self.user)
        
        # Пытаемся удалить пост
        response = self.client.delete(f"/posts/{self.post.id}/")
        
        # Должен быть успех (204 No Content)
        self.assertEqual(response.status_code, 204)
```

— Что происходит в этом тесте? — спросил Винни-Пух.

— Это тест проверяет, что владелец поста МОЖЕТ удалить свой пост, — объяснил Филин. — Давайте 
по шагам:

1. <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">self.client.force_authenticate(user=self.user)</span> — "притворяемся", что текущий пользователь — это 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.user</span> (владелец поста)

2. <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">self.client.delete(f"/posts/{self.post.id}/")</span> — отправляем **DELETE**-запрос на удаление поста

3. <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">self.assertEqual(response.status_code, 204)</span> — проверяем, что статус ответа равен 
204 (успешное удаление)

— Подожди-подожди! — остановил Винни-Пух. — Я вижу здесь 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.post.id</span>, но откуда берётся этот **ID**? Мы же нигде не говорим **"ID=5"**! Как тест узнает, 
какой пост удалять?

— Отличный вопрос, Винни-Пух! — сказал Филин. — Давай пройдём по шагам, что происходит 
ДО запуска теста.

— В методе 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
setUp()</span> мы создаём реальный пост в базе данных:

```python
self.post = Post.objects.create(...)
```

— Когда Django создаёт новый объект в базе данных, он автоматически присваивает ему уникальный 
**ID**! Это как порядковый номер в очереди: первый пост получает **ID=1**, второй — **ID=2**
и так далее.

— Так что после выполнения 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
setUp()</span> у self.post.id уже есть реальный числовой **ID**, который создала база данных!

— В тесте 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
f"/posts/{self.post.id}/"</span> подставляет этот реальный **ID** в **URL**. Например, если 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.post.id = 5</span>, получается 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
"/posts/5/"</span>.

— Когда мы отправляем **DELETE**-запрос на 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/posts/5/</span>, **Django**:

1. Видит **URL** 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
/posts/5/</span>

2. Понимает, что это шаблон 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
posts/<int:pk>/</span>

3. Извлекает число **5** из **URL**

4. Говорит: "Ага, **pk = 5!**"

5. Передаёт **pk=5** в метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>

— И метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
destroy(self, request, pk=None)</span> получает **pk=5**!

— Так что нам не нужно указывать номер вручную! База данных сама назначает **ID**
при создании поста, а тест использует этот реальный **ID**!

— Ой-ой-ой! — запищал Пятачок. — Что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
TestCase</span>? Ты говорил «утверждения для проверок» — что это за утверждения?

— Отличный вопрос! — сказал Филин. — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
TestCase</span> — это специальный контейнер для тестов от **Django**. А «утверждения» (**assertions**)
— это специальные команды-проверки!

— Представь, — продолжил Филин, — ты говоришь: «Я УТВЕРЖДАЮ, что в коробке 5 конфет!» 
Потом открываешь коробку и считаешь. Если там действительно 5 конфет — твоё утверждение 
верно. Если 4 или 6 — утверждение ложно!

— В тестах мы используем утверждения для проверок:

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">assertEqual(a, b)</span> — «Утверждаю, что a РАВНО b!»

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">assertTrue(x)</span> — «Утверждаю, что x — ИСТИНА!»

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">assertFalse(x)</span> — «Утверждаю, что x — ЛОЖЬ!»

+ <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">assertIn(item, list)</span> — «Утверждаю, что item ЕСТЬ в списке!»

— А что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.assertEqual(response.status_code, 204)</span>? — спросил Винни-Пух.

— Это значит: «Я УТВЕРЖДАЮ, что статус код ответа РАВЕН 204!» — объяснил Филин. — 
Если ответ действительно имеет статус 204 — тест проходит. Если нет (например, 403 или 404)
— тест проваливается с ошибкой!

— Теперь второй тест, — продолжил Филин.

```python
    def test_admin_permission_success(self):
        """Админ может удалять любой пост (даже не свой)"""
        # Аутентифицируем как админа
        self.client.force_authenticate(user=self.admin)
        
        # Пытаемся удалить пост
        response = self.client.delete(f"/posts/{self.post.id}/")
        
        # Админ тоже должен иметь доступ
        self.assertEqual(response.status_code, 204)
```

— Этот тест проверяет, что администратор имеет особые права, — объяснил Филин. — Даже если 
пост принадлежит другому пользователю (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.user</span>), админ (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.admin</span>) может его удалить!

— Значит, админу можно всё? — спросил Пятачок.

— Почти всё! — улыбнулся Филин. — Администраторы обычно имеют права на все операции. Но в 
реальном проекте можно создать и более сложные правила!

— И третий тест, — сказал Филин.

```python
    def test_no_permission(self):
        """Чужой пользователь не может удалить пост"""
        # Создаём другого пользователя
        another_user = User.objects.create_user(
            username="another",
            password="password",
            email="another@example.com"
        )
        
        # Аутентифицируем как другого пользователя
        self.client.force_authenticate(user=another_user)
        
        # Пытаемся удалить чужой пост
        response = self.client.delete(f"/posts/{self.post.id}/")
        
        # Должна быть ошибка 403 Forbidden
        self.assertEqual(response.status_code, 403)
```

— А этот тест проверяет обратную ситуацию! — сказал Кролик. — Чужой пользователь НЕ может 
удалить не свой пост!

— Совершенно верно! — подтвердил Филин. — Здесь мы создаём совершенно нового пользователя 

another_user, который не имеет никакого отношения к посту. И когда он пытается удалить 
чужой пост — получает ошибка 403 "Доступ запрещён"!

— Видите логику? — спросил Филин. — Мы тестируем три сценария:

+ Владелец удаляет свой пост — должно работать (статус 204)

+ Админ удаляет чужой пост — тоже должно работать (у админа есть права на всё)

+ Чужой пользователь удаляет не свой пост — должно НЕ работать (статус 403, доступ запрещён)

— Если все три теста проходят — наше разрешение IsOwner работает правильно!

— А как же запустить эти тесты на практике? — спросил Винни-Пух. — Ты обещал рассказать!

— Конечно! — сказал Филин. — После того как мы написали все тесты, нужно их запустить. 
Давайте я покажу, как это делается:

Как запустить тесты:

1. Откройте терминал (командную строку) в папке с вашим Django-проектом

2. Введите команду: 
```
python manage.py test
```

3. Наблюдайте за магией!

— Что произойдёт? — спросил Пятачок.

— **Django** сделает вот что:

1. Создаст временную тестовую базу данных

2. Запустит метод **setUp()** для подготовки данных

3. По очереди запустит ВСЕ тесты (методы, которые начинаются с **test_**)

4. Для каждого теста покажет результат

— Вы увидите что-то вроде:

```text
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
...
----------------------------------------------------------------------
Ran 3 tests in 0.123s

OK
Destroying test database for alias 'default'...
```

— Если тесты прошли успешно — будет OK и зелёный текст!

— Если какой-то тест упал — будет красный текст с подробным описанием ошибки, например:

```text
FAIL: test_no_permission (myapp.tests.PermissionTests)
----------------------------------------------------------------------
AssertionError: 204 != 403
```

— Это значит, что мы ожидали статус 403, а получили 204. Значит, наш тест неправильный 
или разрешение работает не так, как мы задумали!

— Можно запускать конкретные тесты: 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
python manage.py test myapp.tests.PermissionTests.test_owner_permission_success</span>

— Или все тесты в конкретном модуле: 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
python manage.py test myapp.tests</span>

— Теперь понятно! — сказал Кролик. — Мы пишем тесты, запускаем их командой и смотрим 
результаты в терминале!
— Именно! — подтвердил Филин. — Тестирование — это важная часть разработки, которая 
помогает убедиться, что наш код работает правильно!

**Пример: кастомное разрешение с параметрами**

— А можно сделать разрешение с параметрами? — спросил Кролик. — Например: 
«Только пользователи старше 18 лет»?
— Конечно! — ответил Филин. — Для этого нужно передавать параметры через атрибуты 
представления. Давайте создадим именно такое разрешение — для проверки возраста!

```python
# permissions.py
from rest_framework.permissions import BasePermission
from datetime import date

class IsOlderThan(BasePermission):
    """
    Разрешение позволяет доступ только пользователям старше определённого возраста.
    """
    
    def has_permission(self, request, view):
        # Получаем минимальный возраст из атрибута представления
        min_age = getattr(view, 'min_age', 18)  # По умолчанию 18 лет
        
        if request.user and request.user.is_authenticated:
            if request.user.birth_date:  # Предполагаем, что у пользователя есть поле с датой рождения
                today = date.today()
                age = today.year - request.user.birth_date.year
                # Проверяем, исполнилось ли уже день рождения в этом году
                if (today.month, today.day) < (request.user.birth_date.month, request.user.birth_date.day):
                    age -= 1
                return age >= min_age
        
        return False
```
— Подожди! — остановил Винни-Пух. — Что делает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
getattr(view, 'min_age', 18)</span>?

— Отличный вопрос! — сказал Филин. — 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
getattr()</span> — это встроенная функция Python, которая получает атрибут объекта. Она говорит: 
«У объекта 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
view</span> найди атрибут 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
'min_age'</span>. Если не найдёшь — верни 18 (значение по умолчанию)».

— То есть, если представление задало 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age = 21</span>, то возьмётся 21. Если не задало — возьмётся 18 по умолчанию! — понял Пятачок.

— Именно! — подтвердил Филин. — И обрати внимание: мы предполагаем, что у пользователя есть 
поле 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
birth_date</span> (дата рождения). В реальном проекте тебе нужно добавить такое поле в 
модель пользователя!

— А как использовать это разрешение? — спросил Винни-Пух.

— Вот так! — показал Филин:

```python
# views.py
from rest_framework.views import APIView
from .permissions import IsOlderThan

class BarView(APIView):
    """
    Только для взрослых!
    """
    permission_classes = [IsOlderThan]
    min_age = 21  # Можно задать любой возраст!
    
    def get(self, request):
        return Response({"message": "Добро пожаловать в бар для взрослых!"})
```

— Подожди! — остановил Кролик. — Я вижу, что в классе 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BarView</span> есть атрибут 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age = 21</span>. А в разрешении 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOlderThan</span> есть строка 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
getattr(view, 'min_age', 18)</span>. Как 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age</span> из представления попадает в разрешение?

— Отличный вопрос! — сказал Филин. — Это важный механизм взаимодействия!

— Когда пользователь делает запрос к 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BarView</span>, **DRF**:

Создаёт объект представления 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BarView</span> (вызывает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BarView()</span>)

Создаёт объект разрешения 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOlderThan</span> (вызывает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOlderThan()</span>)

Вызывает метод 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
has_permission()</span> у разрешения, передавая ему 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
request</span> и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
view</span>

— Ключевой момент: параметр 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
view</span> в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
has_permission(self, request, view)</span> — это тот самый объект представления 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BarView</span>!

— Поэтому, когда в разрешении мы пишем 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
getattr(view, 'min_age', 18)</span>, мы говорим:
«У объекта представления (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
view</span>) возьми атрибут 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age</span>. Если у представления нет такого атрибута — используй 18»

— А в представлении 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BarView</span> у нас как раз есть атрибут 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age = 21</span>! Поэтому разрешение берёт значение 21!

— А если я создам другое представление без 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age</span>? — спросил Винни-Пух.

```python
class SomeView(APIView):
    permission_classes = [IsOlderThan]
    # Нет атрибута min_age!
    
    def get(self, request):
        return Response({"message": "Какое-то представление"})
```

— Тогда 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
getattr(view, 'min_age', 18)</span> не найдёт 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age</span> и вернёт значение по умолчанию — 18! — объяснил Филин. — Это и есть гибкость!

— Можно даже сделать так: — продолжил Филин.

```python
class CasinoView(APIView):
    permission_classes = [IsOlderThan]
    min_age = 25  # В казино — с 25

class BarView(APIView):
    permission_classes = [IsOlderThan]
    min_age = 21  # В бар — с 21

class ClubView(APIView):
    permission_classes = [IsOlderThan]
    min_age = 18  # В клуб — с 18
```

— Одно и то же разрешение, но с разными параметрами в разных представлениях! — 
восхитился Пятачок.

— Именно! — подтвердил Филин. — Это и есть мощь кастомных разрешений с параметрами!

Итог дня

— Сегодня мы научились создавать гибкие кастомные разрешения! — подвёл итог Филин. — Мы:

Узнали, что 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermission</span> использует метакласс 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
BasePermissionMetaclass</span> для "волшебства" при создании классов

Поняли, что метакласс — это "фабрика классов", которая создаёт сами классы

Создали простые кастомные разрешения (
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsEmailVerified</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsOwner</span>)

Узнали, что 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_authenticated</span> — это свойство **Django**, а не поле в БД

Поняли, что 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_email_verified</span> нужно создавать самому в кастомной модели пользователя

Полностью разобрали 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span> — базовый строительный блок для **API**-комнат

Поняли разницу между 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
APIView</span> (ручная настройка) и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span> (автоматизация)

Подробно разобрали ВСЕ методы 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span> по одному: 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
list</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
retrieve</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
create</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
update</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
partial_update</span>, 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
destroy</span>

Узнали, что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
.data</span> у сериализатора — уже готовые преобразованные данные

Поняли методы 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get_serializer()</span> и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
is_valid()</span> с их параметрами

Подробно разобрали роутеры: 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
DefaultRouter()</span> и 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
router.register()</span>

Узнали, как 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
r'toys'</span> создаёт префикс для **URL** и почему нужна сырая строка

Поняли, что 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
obj.user == request.user</span> проверяет, является ли пользователь автором объекта

Поняли, почему в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get_permissions()</span> нужно писать 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
IsAuthenticated()</span> со скобками (создание экземпляра)

Научились применять разрешения в 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>

Поняли, как работают **URL** для 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>

Узнали про 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
TestCase и утверждения — как писать и запускать тесты

Поняли, как 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
.pk</span> автоматически извлекается из **URL** и передаётся в методы 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>

Узнали, как запускать тесты командой 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
python manage.py test</span> и где смотреть результаты

Разобрали тесты по одному, поняли логику каждого теста

Разобрали, откуда берутся тестовые данные и что модель нужно создавать в реальном проекте

Поняли утверждения 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
assertEqual</span> и как они работают в тестах

Узнали про динамические разрешения через 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
get_permissions()</span>

Поняли, что такое 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
self.action</span> и стандартные действия 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ViewSet</span>

Создали разрешение с параметрами для проверки возраста

Поняли, как 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
min_age</span> из представления попадает в разрешение через 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
getattr()</span>

Научились тестировать разрешения

Создали разрешение с параметрами через 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
getattr()</span> и поняли, как менять параметры для разных представлений

— Теперь мы можем создавать любые правила доступа! — воскликнул Винни-Пух. — Например: 
«Только друзья, которые были в замке на прошлой неделе» или «Только те, у кого больше 
10 банок мёда»!

— Именно! — улыбнулся Филин. — Кастомные разрешения дают безграничные возможности для 
управления доступом в вашем **API**. Используйте их с умом, и ваш замок будет не только 
безопасным, но и удобным для всех друзей!

— А завтра, — пообещал Филин, — мы соберём всё вместе на практическом занятии! Мы создадим 
полноценное **API** с аутентификацией через **JWT** и кастомными разрешениями. 
Вы сами настроите все 
системы безопасности замка!

Жители Леса разошлись, обдумывая, какие интересные правила доступа они могли бы создать 
для своего замка. Теперь они точно понимали, как работает 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">
ModelViewSet</span> и как создавать 
гибкие правила доступа для своего **API**!


# Глава 10: Собираем Всё Вместе — Создаём Свой Замок API
На следующий день все жители Леса собрались с волнением. Сегодня был день практики!

— Друзья! — начал Филин, поправляя очки. — За прошедшие дни мы изучили все основные компоненты 
**Django REST Framework**. Сегодня мы соберём всё вместе и создадим небольшое, но полноценное 
**API** приложение — наш собственный Замок Друзей!

— Мы создадим **API** для управления друзьями, их увлечениями и встречами, — продолжил он. — 
Это будет работающее приложение, которое вы сможете запустить у себя на компьютере и даже 
загрузить на **GitHub**, чтобы весь мир мог увидеть ваши достижения!

Пятачок заёрзал на месте. 

— Ой, а это не сложно? Мы же только учились!

— Именно поэтому и нужно практиковаться! — ободряюще сказал Филин. — Как говорит мой дедушка: «Теория без практики — как мёд без ложки. И то, и другое есть, но насладиться невозможно!»

Винни-Пух задумчиво почесал голову. 

— А мёд-то при чём? Я бы сейчас с удовольствием...

— Сосредоточься, Винни-Пух! — строго сказал Кролик. — Сегодня мы строим замок, а не ищем мёд!

## Структура нашего проекта

— Наше приложение будет состоять из шести основных частей, — начал объяснять Филин, показывая 
на доске:

1. Модели (база данных) — как фундамент замка. Здесь будут жить данные о Друзьях, Увлечениях и 
Встречах.

2. Сериализаторы (преобразователи данных) — как переводчики в замке. Они переводят данные с 
языка базы данных на язык **API**.

3. ViewSets (**API**-комнаты) — как комнаты в замке. Каждая комната отвечает за определённую 
операцию.

4. Кастомные разрешения (наши правила доступа) — как стражи у дверей. Решают, кого пускать в 
каждую комнату.

5. Аутентификация через **JWT** (система пропусков) — как пропускная система замка. Даёт 
специальные ключи гостям.

6. Тесты (проверка работы) — как инспекторы, проверяющие, всё ли в замке работает правильно.

— Ух ты! — воскликнул Пятачок. — Это же целый замок получится!

— Именно! — улыбнулся Филин. — И мы построим его от фундамента до крыши. Начнём?

## Часть 1: Подготовка строительной площадки
— Представьте, что мы архитекторы, — начал Филин. — Прежде чем строить замок, нужно 
подготовить место и инструменты.

### Шаг 1.1: Создаём виртуальное окружение
— Первое, что делает уважающий себя архитектор, — создаёт отдельную мастерскую для проекта! 
— сказал Филин.

```bash
python -m venv venv
```

Кролик наклонился к экрану. 

— А что это за команда?

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">python -m venv 
venv</span> создаёт виртуальное окружение, — объяснил Филин. — Это как отдельная 
комната-мастерская, где будут храниться все инструменты именно для этого проекта. 
Так инструменты одного замка не перепутаются с инструментами другого!

— Как в моей кладовке! — оживился Винни-Пух. — Отдельная полка для горшочков с мёдом, 
отдельная — для банок с вареньем...

— Примерно так, — согласился Филин. — Только вместо варенья у нас библиотеки **Python**.

Активируем его (для Windows):

```bash
venv\Scripts\activate
````
— Посмотрите! — показал Филин. — Теперь в начале строки терминала появилось 
<span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">(venv)</span>. 
Это значит, мы внутри нашей виртуальной мастерской!

### Шаг 1.3: Устанавливаем Django
— Теперь установим сам Django в нашу мастерскую! — сказал Филин.

```bash
pip install django
```

— Что делает эта команда? — спросил Пятачок.

— <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">pip install 
django</span> устанавливает фреймворк Django в наше виртуальное окружение, — объяснил 
Филин. — Это как принести в мастерскую основной набор строительных инструментов.

### Шаг 1.4: Устанавливаем DRF
— Теперь установим **Django REST Framework**, — продолжил Филин.

```bash
pip install djangorestframework
```

— А это что? — спросил Кролик.

— Это специальные инструменты для создания **API**, — ответил Филин. — Если **Django** — это 
общие строительные инструменты, то **DRF** — это специальные инструменты для создания дверей, 
окон и комнат нашего **API**-замка.

### Шаг 1.5: Устанавливаем JWT
— И последнее — система безопасности, — сказал Филин.

```bash
pip install djangorestframework-simplejwt
```

— **JWT** — это **JSON Web Tokens**, — объяснил Филин, видя вопросительный взгляд Винни-Пуха. — 
Это специальные пропуска для нашего замка. Когда друг приходит в замок, он получает такой 
пропуск и показывает его при входе в каждую комнату.

### Шаг 1.6: Создаём requirements.txt
— Теперь сохраним список всех наших инструментов, — сказал Филин.

```bash
pip freeze > requirements.txt
```

— Что это делает? — спросил Кролик.

— Команда <span style="background-color: #bbb; padding: 2px 8px; border-radius: 4px">pip freeze
</span> показывает все установленные **Python** пакеты в нашем виртуальном окружении, 
— объяснил Филин. — А символ 
<span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">></span> 
перенаправляет этот список в файл 
<span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">
requirements.txt</span>.

— Значит файл создастся? — уточнил Пятачок.

— Да! — подтвердил Филин. — В текущей папке появится файл 
<span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">
requirements.txt</span> со списком всех 
установленных библиотек и их версий.

### Шаг 1.7: Проверяем созданный файл

— Давайте посмотрим, что у нас получилось, — предложил Филин.

```bash
type requirements.txt
```

— Команда <span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">type</span>
на Windows показывает содержимое файла, — объяснил Филин. — Вы должны увидеть 
примерно так:

```text
Django==4.2.0
djangorestframework==3.14.0
djangorestframework-simplejwt==5.3.0
```

— Теперь у нас есть список всех инструментов!

### Шаг 1.8: Создаём Django проект
— Теперь создадим сам проект Django, — сказал Филин.

```bash
django-admin startproject friend_castle .
```

— Обратите внимание на точку в конце! — предупредил Филин. — Она означает «создай проект 
в текущей папке», а не в новой вложенной папке.

### Шаг 1.9: Исследуем территорию замка Friend-Castle 🗺️🍯

Винни-Пух, Пятачок и Кролик стояли перед только что созданным проектом. Филин развернул перед ними волшебную карту:

```text
friend_castle/
│
├── 🪄 manage.py
└── friend_castle
    │
    ├── 🏷️ __init__.py
    ├── 🚪 asgi.py
    ├── 🚪 wsgi.py
    ├── 👑 settings.py
    └── 🗺️ urls.py
```

Винни-Пух потянулся к карте: — Ой-ой-ой! Что все эти штучки означают?

**🪄 manage.py — Волшебная палочка Гарри Поттера**

— Это твоя волшебная палочка! — улыбнулся Филин. — С её помощью ты можешь:

+ Произнести **runserver** — и замок оживёт! 🏰

+ Сказать **startapp friends** — и появится новая комната для друзей!

+ Приказать **migrate** — и мебель сама расставится по местам!

Пятачок: — Как моя лопатка для огорода! Маленькая, но без неё никуда!

**🏷️ init.py — Невидимая магическая печать**

— Этот почти пустой файл — как волшебная печать на паспорте, — объяснил Филин. — Он 
шепчет **Python**: «Эту папку можно считать волшебной! Здесь живут заклинания!». Без этой 
печати **Python** пройдёт мимо, не заметив наших сокровищ.

**👑 settings.py — Большая книга законов королевства**

Кролик заглянул в файл и ахнул: — Целые тома правил!

— Именно! — подтвердил Филин. — Здесь записано ВСЁ:

+ Какие приложения-комнаты разрешены в замке

+ Где хранить сокровища (база данных — наш банк мёда!) 🍯

+ На каком языке говорят жители (**'ru-ru'** — по-русски!)

+ Самый главный секрет — **SECRET_KEY** (как секретный рецепт Пуха для лучшего мёда!)

**🗺️ urls.py — Карта всех тропинок и дорожек**

— А это — карта! — воскликнул Филин. — Пока здесь только одна дорожка:

```python
path('admin/', admin.site.urls)  # ведёт в тронный зал
```

— Но скоро появятся:

+ Тропинка к домику Пуха 🍯

+ Дорожка к огороду Кролика 🥕

+ Тропа к дому Пятачка 🏠

**🚪 asgi.py и wsgi.py — Два переводчика у трона короля**

Кролик нахмурился: — Зачем два переводчика? Один бы справился!

Филин взял два колокольчика: — Позвольте объяснить на примере почты!

**🛡️ wsgi.py — Старый почтальон Пётр**

Вообразите почтальона Петра, который:

+ Принимает одно письмо 📨

+ Относит его королю 👑

+ Ждёт ответа ⏳

+ Относит ответ обратно 📨

+ Только потом берёт следующее письмо

Винни-Пух: — Как я с горшочком мёда! Сначала один, потом другой!

**⚡ asgi.py — Современная почтовая команда**

А теперь представьте целую команду почтальонов, которые:

+ Берут много писем сразу 📨📨📨

+ Относят все королю одновременно 👑

+ Могут доставлять даже видеописьма (WebSockets) 🎥

+ Работают все сразу, не мешая друг другу!

Пятачок: — О! Как муравьи в муравейнике! Все вместе носят!

**🤔 А кто же открывает дверь в замок?**

— Вот тут самое важное! — поднял палец Филин. — Эти файлы НЕ дверь!

Настоящую дверь делают могучие стражи:

+ **Nginx** — огромный медведь у ворот 🐻

+ **Apache** — старый, мудрый филин 🦉

+ **Gunicorn** — верный пёс короля 🐕

А наши asgi.py и wsgi.py — это личные секретари короля, которые:

+ Стоят у трона

+ Принимают сообщения от стражей

+ Переводят с языка HTTP на язык Python

+ Отдают ответ для передачи обратно

**🍯 Пример на мёде:**
1. Ты кричишь: «Мёда!» 🗣️ (HTTP-запрос)

2. Страж Nginx слышит и говорит секретарю 🐻→👨‍💼

3. Секретарь WSGI переводит пчёлам: «Дайте мёду!» 👨‍💼→🐝

4. Пчёлы дают мёд 🍯 (Django работает)

5. Секретарь передаёт тебе: «Держи!» 👨‍💼→🧸

Без секретаря-переводчика ты бы кричал, а пчёлы не понимали!

**🎯 Зачем оба файла?**

— Django теперь умный! — сказал Филин. —

+ Сначала используем старого, проверенного секретаря (**WSGI**)

+ Если друзей станет много и захотим чат — позовём молодого, быстрого секретаря (**ASGI**)

Винни-Пух хлопнул в ладоши: — Понял! У меня есть большая ложка для каши и маленькая для чая! 
Обе нужны, но в разное время!

**🌳 Что дальше?**
Филин посмотрел на друзей: — Наш замок построен, законы написаны, карта готова, переводчики 
наняты. Но в замке пусто!

— Следующий шаг — создадим первую комнату! Комнату друзей!

— Волшебными словами: python manage.py startapp friends_api

Друзья переглянулись. Карта изучена, законы понятны, секретари на местах. Пора заселять замок!

Замок Friend-Castle ждёт первых жителей... Кто поселится первым? 🏰→👫

## Шаг 1.10: Создаём первую комнату — friends_api! 🏠
Филин взял волшебную палочку 
<span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">manage.py</span> 
и произнёс заклинание:

```bash
python manage.py startapp friends_api
```

Лёгкое свечение озарило лес! ✨ Появилась новая папка:

```text
friends_api/
├── 🏷️ __init__.py
├── 👑 admin.py
├── 📦 apps.py
├── 🗃️ models.py
├── 🧪 tests.py
└── 👀 views.py
```

Винни-Пух подбежал ближе:

— Ой! Маленький домик в большом замке! А что внутри?

Филин улыбнулся:

— Это наша первая комната, Пух! Здесь мы будем хранить всё, что касается друзей. Но давай посмотрим на каждый файл по порядку.

### 📦 apps.py — Визитная карточка комнаты

Филин открыл первый файл:

```python
# apps.py
from django.apps import AppConfig

class FriendsApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'friends_api'  # ← Вот моё имя!
```

— Это как табличка на двери, — объяснил Филин. — Она говорит: «Здесь живёт приложение 
friends_api!». Без этой таблички главный замок даже не узнает, что эта комната существует.

Кролик прищурился:

— Понятно. А остальные файлы? Что в них?

## 🗃️ models.py — Чертёжная комната

— Вот это — самая важная комната! — сказал Филин, показывая на 
<span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">
models.py</span>. — Здесь мы будем рисовать чертежи того, как выглядит наш Друг.

Пятачок наклонил голову:

— Чертежи друга? Как это?

— Например, — продолжил Филин, — каждый друг имеет:

+ Имя

+ Возраст

+ Любимое занятие

+ Дата, когда мы познакомились

В этом файле мы опишем: «Вот так должен выглядеть запись о друге в нашей базе данных».

## 👀 views.py — Окна в мир

— А это — окна нашей комнаты! — воскликнул Филин. — Каждое окно показывает что-то разное:

+ Одно окно показывает список всех друзей

+ Другое — подробности об одном друге

+ Третье — поиск друзей по интересам

Винни-Пух захлопал в ладоши:

— Как в моём доме! Одно окно на опушку, другое — на речку!

## 👑 admin.py — Секретный вход

— Этот файл — как потайная дверь для Короля, — понизил голос Филин. — Через него администратор (это мы с вами) может:

+ Добавлять новых друзей

+ Редактировать информацию о них

+ Управлять всеми записями

Кролик насторожился:

— Значит, не каждый может туда войти?

— Точно! Только те, у кого есть волшебный ключ!

## 🧪 tests.py — Комната проверок

— А здесь мы будем проверять, что наша комната безопасна и всё работает правильно, — сказал Филин. — Как пробовать мёд, прежде чем угощать гостей!

Пятачок кивнул:

— Умно! Сначала проверить, потом использовать.

## 🏷️ init.py — Волшебная пыль

— Этот почти пустой файл — как волшебная пыль, — улыбнулся Филин. — Он говорит **Python**: 
«Эта папка — особенная! Здесь живут заклинания!». Без этой пыльки **Python** просто пройдёт мимо.

Винни-Пух потёр лапой лоб:

— Много всего... Но вроде понятно! Каждый файл — как отдельная полочка в шкафу!

Филин закрыл папку:

— Именно, Пух! А теперь самый важный шаг: нужно повесить табличку на дверь этой комнаты 
в главном замке!

— Как это сделать? — спросил Кролик.

— Об этом — в следующем шаге! Нужно добавить 
<span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">
'friends_api'</span> в наш 
<span style="background-color: #bbb; padding: 2px 8px; border-radius:4px">
settings.py</span>!

Комната построена, но замок ещё не знает о её существовании... 🏠❌🏰
